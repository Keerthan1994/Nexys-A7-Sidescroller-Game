; -----------------------------------------------------------------
; bot31_pgm.psm - BOTSIM 3.1 (Rojobot 3.1 "world" emulator)
;
; Version:			3.12
; Author:			Roy Kravitz
; Last Modified:	22-May-2015		
;
; Revision History
; ================
; 04-Nov-10		RK		Created the first version from bot_pgm.psm (Bot 2.0).  Adds motor speed control
;						and user configurability via an addition I/O port (BOT_Config)
; 16-Nov-11		RK		Created the first version from bot30_pgm.psm (Bot 3.0).  Adds the map bit values
;						to Sensor Register[7:6].  This was done to make it easier for a BOT application
;						to perform special actions using the "Reserved" value (2'b11) of a BOT World map
;						location
; 26-Oct-12		RK		Modified for kcpsm6 and Nexys 3
; 22-May-2015	RK		Modified for Nexys4 and Vivado,  Added dummy jumps in case the Vivado HW Manager
;						still has problems loading the (see Picoblaze Design in Vivado document)
; 03-Jun-2015	RK		Fixed a bug (found by Sumit Sablok) in line 846.  Was s2, should have been s1
;
; Description:
; ============
; This program implements the external world for a rojobot-based design.
; It is responsible for moving the rojobot simulator through the virtual
; world it resides in.  It's other responsibility is to return the value
; of rojobot's proximity and black line sensors.
; This version (1.5) of the program has the rojobot functionality embedded 
; in the it to simplify debug with the simulator
;
; The program runs on a XILINX picoblaze which connects to verilog
; modules for the world map (map.v) and for whatever "external world"
; (aka "the system") is implemented by the user.  
; wrld_if.v presents a register based view of
; the rojobot world to map.v and the rest of the "system".
;
; As is typical of most embedded system programs, bot_pgm's main loop
; is an infinite loop which can be represented by the following pseudo-code:
; 		while (1)  {
;			get motor control input from "the system"
;			simulate the rojobot  (was in rojobot.v)
;			accumulate motor distance changes since the last time rojobot moved
;			if (distance change >= move threshold {
;				calculate new rojobot location coordinates
;				update rojobot's location and orientation
;				get new sensor values
;				update system interface registers
;				clear rojobot distance counters
;				clear accumulated motor distance changes
;			}
;			wait for next sample interval
;		}
;
; Bot 3.0 adds support for variable motor speed and user-settable wheel threshold (which also affects speed).  The
; new options are configured through an additional I/O port  (BOT_Config) which has the following format:
;
;   ---------------------------------------------	
;   | x   x  th[4]  th[3] th[2] th[1] th[0] evs |
;   ---------------------------------------------- 
;		xx			*RESERVED*
;		th[4:0]		Movement threshold.  The number of steps the left and right wheels
;					need to make to move one position on the world map.  The bot makes
;					a step every time the main loop is run.  So, with a threshold of 5,
;					w/ on/off speed control enabled and both motors wheels turning
;					forward it will take roughly 5 * 50ms = 250ms = 1/4 second to advance
;					one position on the grid.
;		evs			Enable Variable Speed.  If evs = 1 the application program can adjust
;					the speed of the wheels.  If evs = 0 = on/off control, the motor speed
;					is fixed at 1 step every time through the main loop.  When variable speed
;					is enabled, both motors are set to the max(left motor speed, right motor speed).
;					This is to ensure that the BOT pivots in place and ony move straight.  If the
;					motor speeds could actually be set individually then the bot could make
;					gradual turns or veer of the line.   I don't want to do the math.
;
; Bot 3.1 modifies the value of the Sensor register to include the map values for that current
; BOT location.  The new encoding of the Sensors register is:
;
;   -----------------------------------------------------	
;   | Map[1]  Map[0]  x  ProxL  ProxR BlkLL BlkLC BlkLR |
;   ----------------------------------------------------- 
;		Map[1:0]	World Map value for the current BOT location
;		x			*RESERVED*
;		ProxL		Proximity Sensor, Left
;		ProxR		Proximity Sensor, Right
;		BlkLL		Black Line Sensor, Left
;		BlkLC		Black Line Sensor, Center
;		BlkLR		Black Line Sensor, Right
;
; Bot 3.11 modifies the delay counter because the Nexys3 runs on a 100MHz system
; clock instead of a 50MHz system clock
; -----------------------------------------------------------------	

; ============================================
; === Register Names                       ===
; === s7 - s0 registers are not dedicated  ===
; === and keep their default names         ===
; ============================================
NAMEREG		sF,		Orient			; rojobot's orientation
NAMEREG		sE,		Mvmnt			; rojobot's movement
NAMEREG		sD,		LocX			; rojobot location - x coordinate
NAMEREG		sC,		LocY			; rojobot location - y coordinate
NAMEREG		sB,		Sensor			; rojobot sensor values
NAMEREG		sA,		Botinf			; rojobot movement and orientation values
NAMEREG		s9,		LMDist			; left motor distance counter
NAMEREG		s8,		RMDist			; right motor distance counter

; ======================
; === Port Addresses ===
; ======================

; system interface registers
CONSTANT	PRD_MOTCTL_IN,	00		; (i) Rojobot motor control input from system
CONSTANT	PWR_LOCX,		01		; (o) X coordinate of rojobot location
CONSTANT	PWR_LOCY,		02		; (o))Y coordinate of rojobot location
CONSTANT	PWR_BOTINFO,	03		; (o) Rojobot info register
CONSTANT	PWR_SENSORS,	04		; (o) Sensor register
CONSTANT	PWR_LMDIST,		05		; (o) Rojobot left motor distance register
CONSTANT	PWR_RMDIST,		06		; (o) Rojobot right motor distance register
CONSTANT	PRW_RSVD07,		07		; () **RESERVED**

; map logic interface ports
CONSTANT	PWR_COLADR,		08		; (o) Column address of map location
CONSTANT	PWR_ROWADR,		09		; (o) Row address of map location
CONSTANT	PRD_LOCINFO,	0A		; (i) location info from map logic
CONSTANT	PRW_RSVD0B,		0B		; () **RESERVED**

; control signals - implemented as I/O ports w/ no data
CONSTANT	PRW_LOADREGS,	0C		; (i/o) load system interface registers
CONSTANT	PRW_LDMOTDIST,  0D		; (i/o) load motor distance counters
CONSTANT	PRW_UPDSYSREGS,	0E		; (i/o) system registers updated flag
CONSTANT	PRW_RSVD0F,		0F		; () **RESERVED**

CONSTANT	PRD_CONFIG,		07		; (i) Rojobot configuration register 

; =================================
; === Scratch Pad RAM Variables ===
; =================================

; next orientation lookup table - this is a nibble orientated 16 entry table (8 bytes)
; first constant is the base.  Others are the table entries
; high nibble of entry is the next orientation if the rojobot is turning right
; low nibble of entry is the next orientation if the rojobot is turning left
CONSTANT	SP_ORTBASE,	00			; table is based at 0x00	

CONSTANT	SP_ORTNO,	17			; entry N - right is NE, left is NW
CONSTANT	SP_ORTNE,	20			; entry NE - right is E, left is N
CONSTANT	SP_ORTEA,	31			; entry E - right is SE, left is NE
CONSTANT	SP_ORTSE,	42			; entry SE - right is S, left is E
CONSTANT	SP_ORTSO,	53			; entry S - right is SW, left is SE
CONSTANT	SP_ORTSW,	64			; entry SW - right is W, left is S
CONSTANT	SP_ORTWE,	75			; entry W - right is NW, left is SW
CONSTANT	SP_ORTNW,	06			; entry NW - right is N, left is W


; new XY lookup table - this is a byte orientated 8 entry table (8 bytes)
; first constant is the base.  Others are the table entries
; high nibble of entry is the increment to get new x coordinate
; low nibble of entry is the increment to get new y coordinate
; entry nibble values:  0=increment by 0, 1=increment by 1,
; F - decrement by 1 (increment by -1)
CONSTANT	SP_XYTBASE,	10			; table is based at 0x10

CONSTANT	SP_XYTNO,	0F			; entry N - X is 0, Y is -1
CONSTANT	SP_XYTNE,	1F			; entry NE - X is 1, Y is -1
CONSTANT	SP_XYTEA,	10			; entry E - X is 1, Y is 0
CONSTANT	SP_XYTSE,	11			; entry SE - X is 1, Y is 1
CONSTANT	SP_XYTSO,	01			; entry S - X is 0, Y is 1
CONSTANT	SP_XYTSW,	F1			; entry SW - X is -1, Y is 1
CONSTANT	SP_XYTWE,	F0			; entry W - X is -1, Y is 0
CONSTANT	SP_XYTNW,	FF			; entry NW - X is -1, Y is -1


; movement lookup table - this is a nibble-oriented 16 entry table (8 bytes)
; first constant is the base.  Others are the table entries
; assumes dir = 1 = FWD, dir = 0 = REV
CONSTANT	SP_MVTBASE,	20			; table is based at 0x20

CONSTANT	SP_MVT10,	00			; entry 1,0 - both motors stopped
CONSTANT	SP_MVT32,	00			; entry 3,2 - both motors stopped
CONSTANT	SP_MVT54,	CE			; entry 5,4 - 5 is SLT, 4 is SRT
CONSTANT	SP_MVT76,	CE			; entry 7,6 - 7 is SLT, 6 is SRT
CONSTANT	SP_MVT98,	CC			; entry 9,8 - 9 is SLT, 8 is SLT
CONSTANT	SP_MVTBA,	EE			; entry B,A - B is SRT, A is SRT
CONSTANT	SP_MVTDC,	D8			; entry D,C - D is FLT, C is REV
CONSTANT	SP_MVTFE,	4F			; entry F,E - F is FWD, E is FRT

; Temp storage
CONSTANT	TEMP1,		3F			; Temporary storage addresses
CONSTANT	TEMP2,		3E	

; Variable motor speed support addresses
CONSTANT	VS_LMTHRSH,	30			; Left Motor Step threshold (set from CONFIG register)
CONSTANT	VS_RMTHRSH,	31			; Right Motor Step threshold (set from CONFIG register)
CONSTANT	VS_MOTCMSK,	32			; Motor control bits mask.  Set to 0x001 for on/off motor control
									; and 0x111 for variable speed control	
CONSTANT	VS_ENVSCTL,	33			; Enable variable speed motor control flag (0 = on/off control, 1 = variable speed control)	



; ================================
; === Virtual world parameters ===
; ================================
CONSTANT	WSIZE_COLS,		80		; Virtual world has 128 columns (x coordinate)
CONSTANT	WSIZE_ROWS,		80		; Virtual world has 128 rows (y coordinate)

; Change these two values to adjust the speed the rojobot moves in the world
; A smaller value will speed up the rojobot and a larger value will slow down the rojobot
CONSTANT	WTHR_LMOT,		05		; accumulated left motor distance for moving rojobot
CONSTANT	WTHR_RMOT,		05		; accumulated right motor distance for moving rojobot

CONSTANT	WSTRT_COL,		40		; initial position for rojobot (col = 128 /2 = 64)
CONSTANT	WSTRT_ROW,		40		; initial position for rojobot (row = 128 /2 = 64)		

CONSTANT	WTYPE_GND,		00		; location type 0 is bare "ground"
CONSTANT	WTYPE_BLKL,		01		; location type 1 is black line	
CONSTANT	WTYPE_OBSTR,	02		; location type 2 is obstruction (or boundary wall)
CONSTANT	WTYPE_RSVD,		03		; location type 3 is reserved


; ==========================
; === Rojobot parameters ===
; ==========================
CONSTANT	DISTCTR_IVAL,	00		; Initial value for rojobot distance counters

CONSTANT	OR_N,			00		; Orientation is North
CONSTANT	OR_NE,			01		; Orientation is Northeast
CONSTANT	OR_E,			02		; Orientation is East
CONSTANT	OR_SE,			03		; Orientation is Southeast
CONSTANT	OR_S,			04		; Orientation is South
CONSTANT	OR_SW,			05		; Orientation is Southwest
CONSTANT	OR_W,			06		; Orientation is West
CONSTANT	OR_NW,			07		; Orientation is Northwest

CONSTANT	MV_STOP,		00		; Movement is stopped
CONSTANT	MV_FWD,			04		; Movement is forward
CONSTANT	MV_REV,			08		; Movement is reverse
CONSTANT	MV_SLT,			0C		; Movement is slow left turn
CONSTANT	MV_FLT,			0D		; Movement is fast left turn
CONSTANT	MV_SRT,			0E		; Movement is slow right turn
CONSTANT	MV_FRT,			0F		; Movement is fast right turn



; ====================
; === Useful masks ===
; ====================

; NOTE:  THIS IMPLEMENTATION HAS SPEED CONTROL
; ALL THREE SPEED BITS FOR EACH MOTOR ARE INTERPETED BUT THERE IS
; AN ASSUMPTION THAT BOTH WHEELS ARE EITHER TURNING AT THE SAME SPEED
; OR ARE STOPPED.  THERE IS NO VEER ALGORITHM OR VARiABLE ARCS

; motor control register
CONSTANT	MSK_RMBITS,		0F		; right motor status is MotCtl[3:0]
CONSTANT	MSK_LMBITS,		F0		; left motor status is MotCtl[7:4]
CONSTANT	MSK_MOTR_STS,	0F		; motor status is in bits[3:0]

; DISABLE SPEED CONTROL BY ONLY LOOKING AT LSB - DEFAULT
CONSTANT	MSK_MOTSPD,		01		; motor speed bits - no speed control

; ENABLE SPEED CONTROL BY LOOKING AT ALL 3 SPEED BITS INSTEAD OF JUST LSB
CONSTANT	MSK_VMOTSPD,	07		; motor speed bits - w/ variable speed control




; ==============================
; === Other useful constants ===
; ==============================		

;Constant to define a software delay of 1us. This must be adjusted to reflect the
;clock applied to KCPSM6. Every instruction executes in 2 clock cycles making the
;calculation highly predictable. The '6' in the following equation even allows for
;'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
;For our 100MHz clock the constant value is (100 - 6)/4 = 23.5 = 24  (18 Hex).
;For clock rates below 10MHz the value of 1 must be used and the operation will
;become lower than intended.
;	
CONSTANT	DELAYVAL_1uS,	24'd		; 1us delay count


; ===============
; === main()  ===
; ===============

ADDRESS	000
start:
				JUMP	main						; workaround to avoid location 3 corruption
				JUMP	main						; by Vivado Hardware Manager.  Bug was flagged by
				JUMP	main						; Ken Chapman and is known to be in 2014.2
				JUMP	main						; Address 003 can be corrupted by Vivado HW manager
													;
;				JUMP	test_wrldIF					; test the world I/F


main:			CALL	init_mvlkuptbl				; initialize movement lookup table
				CALL	init_orlkuptbl				; initialize orientation lookup table
				CALL	init_xylkuptbl				; initialize xy increment lookup table
				LOAD	Orient,	OR_E				; Position the BOT Stopped and facing East
				LOAD	Mvmnt,	MV_STOP	
				LOAD	LocX,	WSTRT_COL			; in the middle of the world
				LOAD	LocY,	WSTRT_ROW			;
				CALL	upd_sysregs					; Display initial values of system registers	
				CALL	init_rojobot				; then initialize the Rojobot
				CALL	upd_distregs				; Display initial values of motor distance counters			
													; and enter main emulation loop


; ===========================
; === Main Emulation Loop ===
; ===========================
emul_lp:		INPUT	s0,	PRD_CONFIG				; get BOT configuration from system and save in S0
				CALL	adjthresh					; adjust wheel thresholds and masks based on configuration 
				INPUT	s0,	PRD_MOTCTL_IN			; get motor controls from "system" and save in s0
				CALL	rojobot						; and simulate rojobot
													; motor status bits are returned in s0								
				CALL	calc_movement				; next calculate the movement-it may have changed
				LOAD	Mvmnt,	s0					; movement is returned in s0 - save it
													; Motor distance updated in rojobot()
				CALL	upd_distregs				; display the motor distance counters	
				CALL	upd_sysregs					; next update the system registers
				FETCH	s0, 	VS_LMTHRSH			; Fetch left motor threshold from scratchpad RAM									
				COMPARE	LMDist,	s0					; has left motor moved more than the threshold?
				JUMP	NC,		emul_lp01			; yes if CF = 0 need to update the world
				COMPARE	s0,		VS_RMTHRSH			; Fetch right motor threshold from scratchpad RAM
				COMPARE	RMDist,	s0					; has right motor moved more than the threshold?
				JUMP	NC,		emul_lp01			; yes if CF = 0 need to update the world
				JUMP	naptime						; no world update needed - it's nap time

;  update the world starts here - global registers and SP RAM locations are affected
;  see description of individual functions for what registers and memory get changed			
emul_lp01:		LOAD	s1,		Orient				; calculate new orientation based on movement
				LOAD	s2,		Mvmnt				; s1 gets current orientation, s2 gets		
				CALL	calc_orient					; current movement. new orientation is
				LOAD	Orient,	s0					; returned in s0.  Save new orientation
				LOAD	s1,		Orient				; get the new location coordinates
				LOAD	s2,		Mvmnt				; s1 gets current orientation, s2 gets movement
				CALL	get_newxy					; on return s0 has x coord and s1 has y coord
				LOAD	LocX,	s0					; and save the new location
				LOAD	LocY,	s1	
				LOAD	LMDist,	DISTCTR_IVAL		; then clear the left and right
				LOAD	RMDist,	DISTCTR_IVAL		; motor distance counters

; nap time - emulation sleeps for 50ms and then starts again
naptime:		CALL	delay_50ms					; software 50ms delay timing loop
				JUMP	emul_lp						; and start again								
								

				
				
				
;**************************************************************************************
; Support functions
;**************************************************************************************	

;*******
; Functions to update system registers
;*******								
		
; =====================================================================
; === upd_sysregs() - updates the system registers                  ===
; === Registers affected: s0, s1, s2,s3, s4, s5, s6, s7             ===
; === Also affects global registers Sensor, Botinf                  ===
; === Uses the rojobot location, orientation, and movement to       ===
; === read the map (for sensors) and build BotInfo register         ===
; === Toggles the "system registers updated" flag                   ===
; =====================================================================

upd_sysregs:	LOAD	s1,		LocX				; s1 and s2 get rojobot location
				LOAD	s2,		LocY				; s0 will get new sensor reg value
				CALL	get_sensors					; get the new sensor register
				LOAD	Sensor,	s0					; and save
				CALL	get_botinfo					; get the new rojobot info register
				LOAD	Botinf,	s0					; and save	
				OUTPUT	LocX,	PWR_LOCX			; update the system interface registers
				OUTPUT	LocY,	PWR_LOCY			; these are holding registers in the
				OUTPUT	Sensor,	PWR_SENSORS			; world_if.v hardware.  The system-visible
				OUTPUT	Botinf,	PWR_BOTINFO			; registers are updated w/ the
				OUTPUT	s0,		PRW_LOADREGS		; LOAD REG signal.  First write toggles to 1
				OUTPUT	s0,		PRW_LOADREGS		; Second write toggles to 0 
				
				OUTPUT	s0,		PRW_UPDSYSREGS		; toggle the "system registers updated" flag
				OUTPUT	s0,		PRW_UPDSYSREGS		; First write togles to 1, second write to 0
				RETURN
				
				
				
; ====================================================================
; === upd_distregs() - updates the system motor distance registers ===
; === Registers affected: None                                     ===
; === Uses the rojobot left and right motor distance registers     ===
; ====================================================================
upd_distregs:	OUTPUT	LMDist,	PWR_LMDIST			; Update left and right motor
				OUTPUT	RMDist, PWR_RMDIST			; distance counters
				OUTPUT	s0,		PRW_LDMOTDIST		; LMOTDIST control signals updates
				OUTPUT	s0,		PRW_LDMOTDIST		; the system registers - toggle 1 then 0
				RETURN

				
;*******
; Functions to look up values
;*******
; =====================================================================
; === lkup_nib() - looks up an entry in a nibble-based lookup table ===
; === Registers affected: s0, s1, s2                                ===
; === s1 contains the value to lookup,  s2 contains the base        ===
; === address of the table.  entry is returned in low nibble of s0  ===
; =====================================================================
lkup_nib:		LOAD	s0,		s1					; save value to lookup in s0
				SR0		s0							; 2 entries/byte to divide by 2
				ADD		s2,		s0					; add to table base to get offset
				fetch	s0,		(s2)				; and fetch the entry
				SR0		s1							; test if value is even or odd
				JUMP	NC,		lkup_nib01			; if CY = 1 it's odd entry in table
				SR0		s0							; so shift high nibble to low nibble
				SR0		s0							;
				SR0		s0							;
				SR0		s0							;
				RETURN								; and return
lkup_nib01:		AND		s0,		0F					; entry in low nibble so mask 
				RETURN								; out upper nibble and return

				
		
; =====================================================================
; === lkup_byte() - looks up an entry in a byte-based lookup table  ===
; === Registers affected: s0, s1, s2                                ===
; === s1 contains the value to lookup,  s2 contains the base        ===
; === address of the table.  entry is returned in s0                ===
; =====================================================================
lkup_byte:		ADD		s2,		s1					; add to table base to get offset
				fetch	s0,		(s2)				; and fetch the entry
				RETURN	
	
				
											
;*******
; Functions to calculate movement
;*******				

; =====================================================================
; === init_mvlkuptbl() - initialize movement lookup table in SP RAM ===
; === Registers affected: s0, s1                                    ===
; =====================================================================
init_mvlkuptbl:	LOAD	s0,		SP_MVTBASE			; s0 gets base of movement lookup table
				LOAD	s1,		SP_MVT10			; s1 gets values for entries 1 and 0								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_MVT32			; s1 gets values for entries 3 and 2								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_MVT54			; s1 gets values for entries 5 and 4								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_MVT76			; s1 gets values for entries 7 and 6								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index	
				LOAD	s1,		SP_MVT98			; s1 gets values for entries 9 and 8								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_MVTBA			; s1 gets values for entries 11 and 10								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_MVTDC			; s1 gets values for entries 13 and 12								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_MVTFE			; s1 gets values for entries 15 and 14								
				STORE	s1,		(s0)				; store the entry in the table
				RETURN								; done...at last				
				
														
; ===========================================================================
; === calc_movement() - uses motor status register bits[3:0] to calculate ===
; === the rojobot's movement (fwd, rev, stopped, etc.)                    ===
; === Registers affected: s0, s1, s2                                      ===
; === s0 contains the contents of motor status reg, result returned in s0 ===
; === The calculation is done by looking up the movement in the nibble    ===
; === based movement lookup table                                         ===
; ===========================================================================
calc_movement:	LOAD	s1,		s0					; move motor status to s1
				AND		s1,		MSK_MOTR_STS		; isolate the motor on and direction bits
				LOAD	s2,		SP_MVTBASE			; s2 gets base of movement lookup table
				CALL	lkup_nib					; look up the movement
				RETURN								; results are returned in s0				


;*******
; Functions to calculate orientation
;*******				

; ========================================================================
; === init_orlkuptbl() - initialize orientation lookup table in SP RAM ===
; === Registers affected: s0, s1                                       ===
; ========================================================================
init_orlkuptbl:	LOAD	s0,		SP_ORTBASE			; s0 gets base of orientation lookup table
				LOAD	s1,		SP_ORTNO			; s1 gets values for entries for North								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_ORTNE			; s1 gets values for entries Northeast								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_ORTEA			; s1 gets values for entries East								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_ORTSE			; s1 gets values for entries Southeast								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index	
				LOAD	s1,		SP_ORTSO			; s1 gets values for entries South								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_ORTSW			; s1 gets values for entries Southwest								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_ORTWE			; s1 gets values for entries West								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_ORTNW			; s1 gets values for entries Northwest								
				STORE	s1,		(s0)				; store the entry in the table
				RETURN								; done...at last				
				
														
; =========================================================================
; === next_orient() - selects next orientation                          ===
; === Registers affected: s0, s1, s2, s3                                ===
; === s1 contains the current orientation, s2 contains the base address ===
; === of the table, s3 contains the direction.                          ===
; === s3=1 says turning right, s3=0 says turning left, new value is     ===
; === returned in s0.                                                   === 
; === The calculation is done by looking up the orientation in the      ===
; === nibble-based orientation lookup table                             ===
; =========================================================================
next_orient:	SL0		s1							; adjust for 2 entries per orientation
				ADD		s1,		s3					; adjust for left/right turn
				LOAD	s2,		SP_ORTBASE			; s2 gets base of orientation lookup table
				CALL	lkup_nib					; look up the orientation
				RETURN								; results are returned in s0
				
				
; ==========================================================================
; === calc_orient() - calculates new orientation                         ===
; === Registers affected: s0, s1, s2, s3, s4, s5                         ===
; === s1 contains the current orientation, s2 contains the current       ===
; === movement.  On return s0 contains new orientation.                  ===
; === s4 and s5 are used as temporary registers                          ===
; === The calculation is done by a switch statment based on the movement ===
; ==========================================================================				
calc_orient:	LOAD	s4,		s1					; save the current orientation
				LOAD	s5,		s2					; save the current movement
													; switch (movement) {
co_caseSTOP:	COMPARE	s5,		MV_STOP				;	case(MV_STOP):
				JUMP	NZ,		co_caseFWD			; 
				LOAD	s0,		s4					;		s0 = current orientation
				JUMP	co_endcase					;
													;
co_caseFWD:		COMPARE	s5,		MV_FWD				;	case (MV_FWD):
				JUMP	NZ,		co_caseREV			;
				LOAD	s0,		s4					;		s0 = current orientation				
				JUMP	co_endcase					;
													;
co_caseREV:		COMPARE	s5,		MV_REV				;	case (MV_REV):
				JUMP	NZ,		co_caseSLT			;
				LOAD	s0,		s4					;		s0 = current orientation
				JUMP	co_endcase					;
													;											
co_caseSLT:		COMPARE	s5,		MV_SLT				;	case (MV_SLT):
				JUMP	NZ,		co_caseFLT			;
				LOAD	s1,		s4					; 		s0 = next_orient(				     
				LOAD	s3,		00					;		  current orientation					
				CALL	next_orient					; 		  turning left)
				JUMP	co_endcase					;
													;
co_caseFLT:		COMPARE	s5,		MV_FLT				;	case (MV_FLT):
				JUMP	NZ,		co_caseSRT			;
				LOAD	s1,		s4					; 		s0 = next_orient(				     
				LOAD	s3,		00					;		  current orientation					
				CALL	next_orient					; 		  turning left)
				LOAD	s1,		s0					; 		s0 = next_orient(				     
				LOAD	s3,		00					;		  current orientation					
				CALL	next_orient					; 		  turning left)
				JUMP	co_endcase					;
													;
co_caseSRT:		COMPARE	s5,		MV_SRT				;	case (MV_SRT):
				JUMP	NZ,		co_caseFRT			;
				LOAD	s1,		s4					; 		s0 = next_orient(				     
				LOAD	s3,		01					;		  current orientation					
				CALL	next_orient					; 		  turning right)
				JUMP	co_endcase					;
													;
co_caseFRT:		COMPARE	s5,		MV_FRT				;	case (MV_FRT):
				JUMP	NZ,		co_caseDFLT			;
				LOAD	s1,		s4					; 		s0 = next_orient(				     
				LOAD	s3,		01					;		  current orientation					
				CALL	next_orient					; 		  turning right)
				LOAD	s1,		s0					; 		s0 = next_orient(				     
				LOAD	s3,		01					;		  current orientation					
				CALL	next_orient					; 		  turning right)
				JUMP	co_endcase					;
													;
co_caseDFLT:	LOAD	s0,		s4					;	default:
													; 		s0 = current_orientation
co_endcase:		RETURN								; return new orientation in s0


;*******
; Functions to calculate new location coordinates
;*******				

; =====================================================================
; === init_xylkuptbl() - initialize xy incr  lookup table in SP RAM ===
; === Registers affected: s0, s1                                    ===
; =====================================================================
init_xylkuptbl:	LOAD	s0,		SP_XYTBASE			; s0 gets base of xy increment lookup table
				LOAD	s1,		SP_XYTNO			; s1 gets values for entries for North								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_XYTNE			; s1 gets values for entries Northeast								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_XYTEA			; s1 gets values for entries East								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_XYTSE			; s1 gets values for entries Southeast								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index	
				LOAD	s1,		SP_XYTSO			; s1 gets values for entries South								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_XYTSW			; s1 gets values for entries Southwest								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index				
				LOAD	s1,		SP_XYTWE			; s1 gets values for entries West								
				STORE	s1,		(s0)				; store the entry in the table
				ADD		s0,		01					; increment the table index
				LOAD	s1,		SP_XYTNW			; s1 gets values for entries Northwest								
				STORE	s1,		(s0)				; store the entry in the table
				RETURN								; done...at last	

				
; =========================================================================
; === next_xy() - returns x and y increment values for next location    ===
; === Registers affected: s0, s1, s2, s3                                ===
; === s1 contains the current orientation, s2 contains the base address ===
; === of the table.  The x increment is returned in s0 and the y        ===
; === increment is returned in s1                                       === 
; === The calculation is done by looking up the increments in the       ===
; === byte-based xy lookup table.  The x increment is in the upper      ===
; === nibble and the y increment is in the lower nibble of the entries  ===
; =========================================================================
next_xy:		LOAD	s2,		SP_XYTBASE			; s2 gets base of xy increment lookup table
				CALL	lkup_byte					; look up the orientation
				LOAD	s1,		s0					; s1 gets copy of results
				AND		s1,		0F					; low nibble is y increment
				SR0		s0							; shift s0 x 4 to move
				SR0		s0							; high nibble down
				SR0		s0							;
				SR0		s0							;
				RETURN								; return

				
; =========================================================================
; === get_newxy() - returns x and y coordinates for new Rojobot location===
; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                ===
; === s1 contains the crnt orientation, s2 contains the crnt movement   ===
; === The new x location is returned in s0 and the new y location       ===
; === is returned in s1.                                                === 
; === The rojobot only changes location when it is moving forward or    ===
; === backward and if the location it is moving into is not obstructed. ===
; ===                                                                   ===                                                                     
; === The function will not move the Rojobot onto an obstructed         ===
; === location.                                                         ===
; =========================================================================
get_newxy:		LOAD	s4, 	s2					; save crnt movement - s2 will change
				LOAD	s5,		s1					; save crnt orientation - s1 will change
				LOAD	s6,		LocX				; save current x coordinate in s6
				LOAD	s7,		LocY				; save current y location in s7
				CALL	next_xy						; s1 contains the orientation
													; on return s0 has x incr, s1 has y incr
													; incr = 0 or 1 or if F incr is -1
													;
				COMPARE	s4,		MV_FWD				; 	if (Mvmnt == FWD)  {
				JUMP	NZ,		gnxy_00				; -- Z != 0 says not FWD, check if REV
				COMPARE	s0,		0F					;		if (xcoord == 0x0F)
				JUMP	NZ,		gnxy_01				; -- Z != says xcoord != 0F
				SUB		s6,		01					;			newx = LocX - 1	
				JUMP	gnxy_02						;		else
gnxy_01:		ADD		s6,		s0					;			newx = LocX + incr (either 0 or 1)
gnxy_02:		COMPARE	s1,		0F					;		if (ycoord = 0x0F)
				JUMP	NZ,		gnxy_03				;			newy = LocY -1
				SUB		s7,		01					;
				JUMP	gnxy_chk0B					;		else
gnxy_03:		ADD		s7,		s1					;			newy = LocY + incr (either 0 or 1)
				JUMP	gnxy_chk0B					;	}  // end Mvmnt == FWD
gnxy_00:		COMPARE	s4,		MV_REV				;	else if (Mvmnt == REV)  {
				JUMP	NZ,		gnxy_nofwdrev		; -- Z != says not REV so position won't change
				COMPARE	s0,		0F					;		if (xcoord == 0x0F)
				JUMP	NZ,		gnxy_04				;
				ADD		s6,		01					;			newx = LocX + 1
				JUMP	gnxy_05						;		else
gnxy_04:		SUB		s6,		s0					;			newx = LocX - incr (either 0 or 1)
gnxy_05:		COMPARE	s1,		0F					;		if (ycoord == 0x0F)
				JUMP	NZ,		gnxy_06				;
				ADD		s7,		01					;			newy = LocY + 1
				JUMP	gnxy_chk0B					;		else
gnxy_06:		SUB		s7,		s1					;			newy = LocY - incr (either 0 or 1)
				JUMP	gnxy_chk0B					;	} // end Mvmnt == REV 
gnxy_nofwdrev:	LOAD	s0,		s6					;  Not forward or reverse so return current X and Y
				LOAD	s1,		s7					;
				RETURN								;	
													;
gnxy_chk0B:		LOAD	s1,		s6					; Check if new location is obstructed
				LOAD	s2,		s7					; s1 = newx,  s2 = new y
				CALL	get_mapvalue				; s0 = value of Map location on return
				COMPARE	s0,		WTYPE_OBSTR			;	if (Map(x,y) == OBSTR)  {
				JUMP	NZ,		gnxy_07				; -- Z != 1 says location is not obstructed
				LOAD	s0,		LocX				;   	s0 = old location (x)
				LOAD	s1,		LocY				;		s1 = old location (y)
				RETURN								;		return
													;	}
gnxy_07:		LOAD	s0,		s6					;	else  {
				LOAD	s1,		s7					;		s0 = newx; s1 = newy;
				RETURN								;		return
				
				
;*******
; Functions to manipulate world map
;*******								
				
; =============================================================================
; === get_mapvalue() - returns the value of map location                    ===
; === Registers affected: s0, s1, s2                                        ===
; === s1 contains the x (col) coordinate and s2 contains the y coordinate   ===
; === of the location to access.  the map value for that location is        ===
; === returns in s0.                                                        ===
; =============================================================================	

get_mapvalue:	OUTPUT	s1,		PWR_COLADR			; send column address to map logic
				OUTPUT	s2,		PWR_ROWADR			; send row address to map logic
				LOAD	s0,		s0					; NOP to give memory plenty of time for read
				INPUT	s0,		PRD_LOCINFO			; and get results from map memory
				RETURN								; all done					

								

;*******
; Functions to generate the external registers
;*******					
; =============================================================================
; === get_sensors() - returns the value of the sensor register              ===
; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                    ===
; === s1 contains the x (col) coordinate, s2 contains the y coordinate      ===
; === of the location to access.  The global register Orient contains the   ===
; === BOT's orientation. The new sensor register value is returned in s0.   ===
; =============================================================================	

													; switch(Orient)  {
get_sensors:	LOAD	s1,		LocX				; get_mapvalue(LocX, LocY)
				LOAD	s2,		LocY				;	
				CALL	get_mapvalue				; s0 = map(LocX, LocY)
				LOAD	s7,		s0					; s7 gets map(LocX, Loc)
gs_caseORN:		COMPARE	Orient,	OR_N				;	case(OR_N):
				JUMP	NZ,		gs_caseORNE			;
				SUB		s1,		01					; 		s4 = gets map(LocX-1, LocY-1)
				SUB		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				ADD		s1,		01					; 		s5 = gets map(LocX, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				ADD		s1,		01					; 		s6 = gets map(LocX+1, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN								;		continue;
													;
gs_caseORNE:	COMPARE	Orient,	OR_NE				;	case (OR_NE):
				JUMP	NZ,		gs_caseORE			;
				ADD		s1,		01					; 		s4 = gets map(LocX+1, LocY-2)
				SUB		s2,		02					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				ADD		s2,		01					; 		s5 = gets map(LocX+1, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				ADD		s1,		01					; 		s6 = gets map(LocX+2, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	
								
gs_caseORE:		COMPARE	Orient,	OR_E				;	case (OR_E):
				JUMP	NZ,		gs_caseORSE			;
				ADD		s1,		01					; 		s4 = gets map(LocX+1, LocY-1)
				SUB		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				ADD		s2,		01					; 		s5 = gets map(LocX+1, LocY)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				ADD		s2,		01					; 		s6 = gets map(LocX+1, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	

gs_caseORSE:	COMPARE	Orient,	OR_SE				;	case (OR_SE):
				JUMP	NZ,		gs_caseORS			;
				ADD		s1,		02					; 		s4 = gets map(LocX+2, LocY+1)
				ADD		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				SUB		s1,		01					; 		s5 = gets map(LocX+1, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				ADD		s2,		01					; 		s6 = gets map(LocX+1, LocY+2)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	
				
gs_caseORS:		COMPARE	Orient,	OR_S				;	case (OR_S):
				JUMP	NZ,		gs_caseORSW			;
				ADD		s1,		01					; 		s4 = gets map(LocX+1, LocY+1)
				ADD		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				SUB		s1,		01					; 		s5 = gets map(LocX, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				SUB		s1,		01					; 		s6 = gets map(LocX-1, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	

gs_caseORSW:	COMPARE	Orient,	OR_SW				;	case (OR_SW):
				JUMP	NZ,		gs_caseORW			;
				SUB		s1,		01					; 		s4 = gets map(LocX-1, LocY+2)
				ADD		s2,		02					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				SUB		s2,		01					; 		s5 = gets map(LocX-1, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				SUB		s1,		01					; 		s6 = gets map(LocX-2, LocY+1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	
				
gs_caseORW:		COMPARE	Orient,	OR_W				;	case (OR_W):
				JUMP	NZ,		gs_caseORNW			;
				SUB		s1,		01					; 		s4 = gets map(LocX-1, LocY+1)
				ADD		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				SUB		s2,		01					; 		s5 = gets map(LocX-1, LocY)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				SUB		s2,		01					; 		s6 = gets map(LocX-1, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN	
				
gs_caseORNW:	COMPARE	Orient,	OR_NW				;	case (OR_NW):
				JUMP	NZ,		gs_errcase			;
				SUB		s1,		02					; 		s4 = gets map(LocX-2, LocY-1)
				SUB		s2,		01					;
				CALL	get_mapvalue				;
				LOAD	s4,		s0					;
				ADD		s1,		01					; 		s5 = gets map(LocX-1, LocY-1)
				CALL	get_mapvalue				;
				LOAD	s5,		s0					;						 
				SUB		s2,		01					; 		s6 = gets map(LocX-1, LocY-2)
				CALL	get_mapvalue				;
				LOAD	s6,		s0					;	
				CALL	set_senvalues				;		s0 = new sensor value		 
				RETURN
gs_errcase:		LOAD	s0,		FF					;	error case - should never get here,
				RETURN								;	so return illegal value	
		
			
												
; ==============================================================================
; === set_senvalues() - sets sensor values based on the locations around bot ===
; === Registers used:  s4,s5,s6 s7.  Registers affected s0                   ===	
; === s4, s5, and s6 contain location type for the left front, center front, ===
; === and right front of the bot.  s7 contains location type for the bot's   ===
; === current location of the bot.  The results are returned in s0           ===
; ==============================================================================

set_senvalues:	LOAD	s0,		s7					; Put the current world location type into bits[7:6]
				SL0		s0							;
				SL0		s0							;
				SL0		s0							;
				SL0		s0							;
				SL0		s0							;
				SL0		s0							;	
				OR		s0,		07					; assume theres no black line and no obstructions
													;
				COMPARE	s7,		WTYPE_BLKL			; if (s7 == Black Line) //crnt loc = black line
				JUMP	NZ,		setsen_L0			; -- Z = 0 says no match
				AND		s0,		F8					;	BlackLine = 000		
setsen_L0:		COMPARE	s5,		WTYPE_OBSTR			; if (s5 == OBSTR) 		// center front = obstruction
				JUMP	NZ,		setsen_L1			; --Z = 0 says no match
				OR		s0,		18					;	ProxL = ProxR = 1
setsen_L1:		COMPARE	s4,		WTYPE_OBSTR			; if (s4 == OBSTR)		// left front = obstruction
				JUMP	NZ,		setsen_L2			; --Z=0 says no match
				OR		s0,		10					;	ProxL = 1
setsen_L2:		COMPARE	s6,		WTYPE_OBSTR			; if (s6 == OBSTR)		// right front = obstruction
				JUMP	NZ,		setsen_L3			; --Z=0 says no macth
				OR		s0,		08					;	ProxR = 1
setsen_L3:		RETURN				
									
	

				
; =============================================================================
; === get_botinfo() - returns the value of the BOT info register            ===
; === Registers affected: s0, s1                                            ===
; === Uses the global registers "Mvmnt" and "Orient"                        ===
; === new botinfo register value is returned in s0.                         ===
; =============================================================================	
get_botinfo:	LOAD	s0,		Mvmnt				; copy current movement to s0
				SL0		s0							; and shift it to bit 4
				SL0		s0							;
				SL0		s0							;
				SL0		s0			;
				LOAD	s1,		Orient				; copy current orientation to s1
				AND		s1,		07					; mask out all but lower three bits
				OR		s0,		s1					; and OR with Mvmnt contents
				RETURN
				

				
;*******
; Functions to implement Rojobot
;*******

; =====================================================================
; === adjthresh() - adjusts paramenters based on BOT configuration  ===
; === Registers affected: s0, s1 and VS_ scratch RAM variables      ===
; === Assumes BOT configuration is in s0                            ===
; =====================================================================
adjthresh:		LOAD	s1,		00					; Assume on/off control
adjthr_onoff:	STORE	s1,		VS_ENVSCTL			; mode = 00 (on/off control)
				LOAD	s1,		MSK_MOTSPD			;
				STORE	s1,		VS_MOTCMSK			; motor control mask = 01 - only look at low order bit
				LOAD	s1,		WTHR_LMOT			; left motor threshold = default for on/off
				STORE	s1,		VS_LMTHRSH			;
				LOAD	s1,		WTHR_RMOT			; right motor threshold = default for on/off
				STORE	s1,		VS_RMTHRSH			;
													; Now check mode and adjust parameters if variable speed enabled					
				SR0		s0							; move mode (on/off or variable speed) to C
				RETURN	NC							; CF=0 says that mode is on/off so nothing to do
													;
adjthr_vs:		LOAD	s1,		01					; otherwise set mode to variable speed
				STORE	s1,		VS_ENVSCTL			;
				LOAD	s1,		MSK_VMOTSPD			; motor control mask = 07 - look at all three motor speed bits
				STORE	s1,		VS_MOTCMSK			;
				LOAD	s1,		s0					; left and right motor thresholds = bits[4:0]
				AND		s1,		1F					;
				STORE	s1,		VS_LMTHRSH			; left and right motor thresholds are the same in this version
				STORE	s1,		VS_RMTHRSH			; of the Rojobot configuration register
				RETURN
				 

						

; =====================================================================
; === init_rojobot() - initialize the rojobot                       ===
; === Registers affected: LMDist, RMDist, Sensor, and Botinf        ===
; === Assumes Orientation and Movement has already been initialized ===
; =====================================================================
init_rojobot:	LOAD	LMDist,	DISTCTR_IVAL		; initialize left and right
				LOAD	RMDist,	DISTCTR_IVAL		; motor distance counters
				LOAD	Sensor,	00					; initialize sensors to 0
				CALL	get_botinfo					; initialize BotInfo register
				LOAD	Botinf,	s0					;
				RETURN
				
; =====================================================================
; === rojobot() - simulate the rojobot                              ===
; === Registers affected: LMDist, RMDist, s0, s1, s2, s3            ===
; === Functions looks at MotCtl and adjusts the distance counters   ===
; === based on what each of the motors is doing.  Matches motor     ===
; === speeds by making slower motor move faster.  Returns motor     ===
; === status (lm_on, rm_on, lm_dir, rm_dir) in s0 for use by the    ===
; === calc_movement() function.  MotCtl is passed in s0             ===
; =====================================================================
rojobot:		LOAD	s1,		s0					; s1[3:0] gets right motor control
				AND		s1,		MSK_RMBITS			;
				LOAD	s2,		s0					; s2[3:0] gets left motor control
				SR0		s2							; after you shift it down 4 bits
				SR0		s2							;
				SR0		s2							;
				SR0		s2							;
													; Handle the motor direction bits
				SR0		s1							; put rm_dir into carry-bit
				SRA		s0							; and move it to s0[7] to
													; start building motor status
				SR0		s2							; put lm_dir into carry-bit
				SRA		s0							; and shift it into place
				SR0		s0							; set rm_on and lm_on to "off" by shifting zeros into bits[7:6]
				SR0		s0							; the shift also moves lm_dir and rm_dir into bits[5:4]
													;
													; Isolate the speed bits
				FETCH	s3,		VS_MOTCMSK			; Load the speed bit mask
				AND		s1,		s3					; mask out right motor speed
				AND		s2,		s3					; mask out left motor speed	
													;		
				COMPARE	s1,		00					; Is the right motor moving?
				JUMP	Z,		rojobot_01			; --ZF is 1 says right motor speed == 0	
				COMPARE	s1,		s2					; right motor is moving. Is right motor speed < left motor speed?
				JUMP	NC,		rojobot_02			; --CF is 0 says right motor speed >= left motor speed
				LOAD	s1,		s2					; right motor speed < left motor speed so speed up right motor
rojobot_02:		ADD		RMDist,	s1					; update right motor distance ctr
				OR		s0,		40					; and set rm_spd to "on" (1)
													; motor status = rm_on, lm_dir, rm_dir xxxxx
													;
rojobot_01:		COMPARE	s2,		00					; Is the left motor moving?
				JUMP	Z,		rojobot_03			; --ZF is 1 says left motor speed == 0	
				COMPARE	s2,		s1					; left motor is moving.  Is left motor speed < right motor speed?
				JUMP	NC,		rojobot_04			; -- CF is 0 says left motor speed >- right motor speed
				LOAD	s2,		s1					; left motor speed < right motor speed so speed up left motor
rojobot_04:		ADD		LMDist,	s2					; yst it's moving - update distance ctr
				OR		s0,		80					; and set lm_spd to "on" (1)
rojobot_03:		SR0		s0							; almost done - move motor status
				SR0		s0							; to bits [3:0]
				SR0		s0							;
				SR0		s0							;
				RETURN
						
								
									
							
;**************************************************************************************
; Software delay routines  (Courtesy Ken Chapman - Xilinx Corp)
;**************************************************************************************

; ========================================================
; === delay_1us() - delays execution for 1 microsecond ===
; === Registers affected: s0                           ===
; ======================================================== 
delay_1us:		LOAD	s0,		DELAYVAL_1uS	; Load 1us delay constant
wait_1us:		SUB		s0,		01				; count down to 0	
				JUMP 	NZ,		wait_1us		; and then return
				RETURN

; =========================================================== 
; === delay_40us() - delays execution for 40 microseconds ===
; === Registers affected: s0, s1                          ===
; =========================================================== 				
delay_40us:		LOAD	s1, 	28				; 40 x 1us = 40us
wait_40us:		CALL 	delay_1us				; delay 1us
				SUB 	s1, 	01				; count down to 0
				JUMP 	NZ, 	wait_40us		; and then return
				RETURN
                  
; ======================================================== 
; === delay_1 ms() - delays execution for 1 milisecond ===
; === Registers affected: s0, s1, s2                   ===
; ======================================================== 				
delay_1ms:		LOAD	s2, 	19				; 25 x 40us = 1ms
wait_1ms:		CALL 	delay_40us				; delay 40us
				SUB 	s2, 	01				; count down to 0
				JUMP 	NZ, 	wait_1ms		; and then return
				RETURN

; ===================================================================
; === delay_50 ms() - delays execution for 50 miliseconds (20Hz)===
; === Registers affected: s0, s1, s2, s3                          ===
; ===================================================================				
delay_50ms:		LOAD	s3, 	32				; 50 x 1ms = 50ms
wait_50ms:		CALL 	delay_1ms				; delay 1ms
				SUB 	s3, 	01				; count down to 0
				JUMP 	NZ, 	wait_50ms		; and then return
				RETURN
				
;*********************************************************************	
; ===================================================================
; === delay_100 ms() - delays execution for 100 miliseconds (10Hz)===
; === Registers affected: s0, s1, s2, s3                          ===
; ===================================================================				
delay_100ms:	LOAD	s3, 	64				; 100 x 1ms = 100ms
wait_100ms:		CALL 	delay_1ms				; delay 1ms
				SUB 	s3, 	01				; count down to 0
				JUMP 	NZ, 	wait_100ms		; and then return
				RETURN
;*********************************************************************							
			
; ==================================================================
; === delay_200 ms() - delays execution for 200 miliseconds (5Hz)===
; === Registers affected: s0, s1, s2, s3                         ===
; ==================================================================				
delay_200ms:	LOAD	s3, 	C8				; 200 x 1ms = 200ms
wait_200ms:		CALL 	delay_1ms				; delay 1ms
				SUB 	s3, 	01				; count down to 0
				JUMP 	NZ, 	wait_200ms		; and then return
				RETURN
;*********************************************************************


; =============================================================== 
; === delay_1000 ms() - delays execution for 1000 miliseconds ===
; === Registers affected: s0, s1, s2, s3, s4                  ===
; ===============================================================			
delay_1000ms:	LOAD	s4, 	05				; 5 x 200ms = 1000ms
wait_1000ms:	CALL 	delay_200ms				; delay 200ms
				SUB 	s4, 	01				; count down to 0
				JUMP 	NZ, 	wait_1000ms		; and then return
				RETURN
;*******************************************************************



; ****** USE THIS FUNCTION FOR SIMULATION (waits 10 cycles) ******		
; =========================================================== 
; === delay_sim() - delays execution for 10 cycles        ===
; === Registers affected: s0, s1, s2, s3                  ===
; =========================================================== 				
delay_sim:		LOAD	s3, 	0A				; delay 10
wait_sim:		LOAD	s3,		s3				; NOP
				SUB 	s3, 	01				; count down to 0
				JUMP 	NZ, 	wait_sim		; and then return
				RETURN
				
				
				
ADDRESS	300				
;**********************************************************************************************************
;**********************************************************************************************************
;**********************************************************************************************************
;***************          Simple test for the World I/F and Bot logic        ******************************
;**********************************************************************************************************
test_wrldIF:	LOAD	LocX,		00				; initialize LocX and LocY to 0
				LOAD	LocY,		00				;
				LOAD	LMDist,		FF				; initialize LMDist and RMDist to FF
				LOAD	RMDist,		FF				;
				
twrldIF_lp:		INPUT	s0,			PRD_MOTCTL_IN	; get motor controls from "system" and save in s0
				OUTPUT	s0, 		PWR_SENSORS		; and write it to world I/F sensor register
				
				ADD		LocX,		01				; increment LocX
				LOAD	LocY,		LocX			; LocY =2 * LocX
				SL0		LocY						;
				OUTPUT	LocX,		PWR_LOCX		; and output them to world I/F
				OUTPUT	LocY,		PWR_LOCY		;
				OUTPUT	s0,			PRW_LOADREGS	; write them to system I/F by pulsing load_sys_regs
				OUTPUT	s0,			PRW_LOADREGS	;
										
				SUB		LMDist,		02				; decrement LMDist and RMDist registers by 2 and 4
				SUB		RMDist,		04				;
				OUTPUT	LMDist,		PWR_LMDIST		; and write them to world I/F
				OUTPUT	RMDist,		PWR_RMDIST		; 
				OUTPUT	s0,			PRW_LDMOTDIST	; write them to system I/F by pulsing load_dist_regs
				OUTPUT	s0,			PRW_LDMOTDIST	;
				CALL	delay_200ms					; and sleep for 200 ms
				OUTPUT	s0,		PRW_UPDSYSREGS		; toggle the "system registers updated" flag
				OUTPUT	s0,		PRW_UPDSYSREGS		; First write togles to 1, second write to 0
				JUMP	twrldIF_lp					; do this forever
							
				
					