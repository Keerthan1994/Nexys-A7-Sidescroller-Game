KCPSM6 Assembler log file for program 'C:\Users\rromano\Documents\GitHub\Nexys-A7-Sidescroller-Game\PGM Test\KCPSM6_Release9_30Sept14\\PSMS\Sidescroller version 2\bot31_pgm.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 08 Dec 2020
Assembly timestamp: 16:20:35

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 316 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 565
Memory locations available: 3531


Assembly listing

 Addr Code                   Instruction

 000                         ; -----------------------------------------------------------------
 000                         ; bot31_pgm.psm - BOTSIM 3.1 (Rojobot 3.1 "world" emulator)
 000                         ;
 000                         ; Version:   3.12
 000                         ; Author:   Roy Kravitz
 000                         ; Last Modified: 22-May-2015
 000                         ;
 000                         ; Revision History
 000                         ; ================
 000                         ; 04-Nov-10  RK  Created the first version from bot_pgm.psm (Bot 2.0).  Adds motor speed control
 000                         ;      and user configurability via an addition I/O port (BOT_Config)
 000                         ; 16-Nov-11  RK  Created the first version from bot30_pgm.psm (Bot 3.0).  Adds the map bit values
 000                         ;      to Sensor Register[7:6].  This was done to make it easier for a BOT application
 000                         ;      to perform special actions using the "Reserved" value (2'b11) of a BOT World map
 000                         ;      location
 000                         ; 26-Oct-12  RK  Modified for kcpsm6 and Nexys 3
 000                         ; 22-May-2015 RK  Modified for Nexys4 and Vivado,  Added dummy jumps in case the Vivado HW Manager
 000                         ;      still has problems loading the (see Picoblaze Design in Vivado document)
 000                         ; 03-Jun-2015 RK  Fixed a bug (found by Sumit Sablok) in line 846.  Was s2, should have been s1
 000                         ;
 000                         ; Description:
 000                         ; ============
 000                         ; This program implements the external world for a rojobot-based design.
 000                         ; It is responsible for moving the rojobot simulator through the virtual
 000                         ; world it resides in.  It's other responsibility is to return the value
 000                         ; of rojobot's proximity and black line sensors.
 000                         ; This version (1.5) of the program has the rojobot functionality embedded
 000                         ; in the it to simplify debug with the simulator
 000                         ;
 000                         ; The program runs on a XILINX picoblaze which connects to verilog
 000                         ; modules for the world map (map.v) and for whatever "external world"
 000                         ; (aka "the system") is implemented by the user.
 000                         ; wrld_if.v presents a register based view of
 000                         ; the rojobot world to map.v and the rest of the "system".
 000                         ;
 000                         ; As is typical of most embedded system programs, bot_pgm's main loop
 000                         ; is an infinite loop which can be represented by the following pseudo-code:
 000                         ;   while (1)  {
 000                         ;   get motor control input from "the system"
 000                         ;   simulate the rojobot  (was in rojobot.v)
 000                         ;   accumulate motor distance changes since the last time rojobot moved
 000                         ;   if (distance change >= move threshold {
 000                         ;    calculate new rojobot location coordinates
 000                         ;    update rojobot's location and orientation
 000                         ;    get new sensor values
 000                         ;    update system interface registers
 000                         ;    clear rojobot distance counters
 000                         ;    clear accumulated motor distance changes
 000                         ;   }
 000                         ;   wait for next sample interval
 000                         ;  }
 000                         ;
 000                         ; Bot 3.0 adds support for variable motor speed and user-settable wheel threshold (which also affects speed).  The
 000                         ; new options are configured through an additional I/O port  (BOT_Config) which has the following format:
 000                         ;
 000                         ;   ---------------------------------------------
 000                         ;   | x   x  th[4]  th[3] th[2] th[1] th[0] evs |
 000                         ;   ----------------------------------------------
 000                         ;  xx   *RESERVED*
 000                         ;  th[4:0]  Movement threshold.  The number of steps the left and right wheels
 000                         ;     need to make to move one position on the world map.  The bot makes
 000                         ;     a step every time the main loop is run.  So, with a threshold of 5,
 000                         ;     w/ on/off speed control enabled and both motors wheels turning
 000                         ;     forward it will take roughly 5 * 50ms = 250ms = 1/4 second to advance
 000                         ;     one position on the grid.
 000                         ;  evs   Enable Variable Speed.  If evs = 1 the application program can adjust
 000                         ;     the speed of the wheels.  If evs = 0 = on/off control, the motor speed
 000                         ;     is fixed at 1 step every time through the main loop.  When variable speed
 000                         ;     is enabled, both motors are set to the max(left motor speed, right motor speed).
 000                         ;     This is to ensure that the BOT pivots in place and ony move straight.  If the
 000                         ;     motor speeds could actually be set individually then the bot could make
 000                         ;     gradual turns or veer of the line.   I don't want to do the math.
 000                         ;
 000                         ; Bot 3.1 modifies the value of the Sensor register to include the map values for that current
 000                         ; BOT location.  The new encoding of the Sensors register is:
 000                         ;
 000                         ;   -----------------------------------------------------
 000                         ;   | Map[1]  Map[0]  x  ProxL  ProxR BlkLL BlkLC BlkLR |
 000                         ;   -----------------------------------------------------
 000                         ;  Map[1:0] World Map value for the current BOT location
 000                         ;  x   *RESERVED*
 000                         ;  ProxL  Proximity Sensor, Left
 000                         ;  ProxR  Proximity Sensor, Right
 000                         ;  BlkLL  Black Line Sensor, Left
 000                         ;  BlkLC  Black Line Sensor, Center
 000                         ;  BlkLR  Black Line Sensor, Right
 000                         ;
 000                         ; Bot 3.11 modifies the delay counter because the Nexys3 runs on a 100MHz system
 000                         ; clock instead of a 50MHz system clock
 000                         ; -----------------------------------------------------------------
 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s7 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, Orient                 ; rojobot's orientation
 000                         NAMEREG sE, Mvmnt                  ; rojobot's movement
 000                         NAMEREG sD, LocX                   ; rojobot location - x coordinate
 000                         NAMEREG sC, LocY                   ; rojobot location - y coordinate
 000                         NAMEREG sB, Sensor                 ; rojobot sensor values
 000                         NAMEREG sA, Botinf                 ; rojobot movement and orientation values
 000                         NAMEREG s9, LMDist                 ; left motor distance counter
 000                         NAMEREG s8, RMDist                 ; right motor distance counter
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ; system interface registers
 000                         CONSTANT PRD_MOTCTL_IN, 00         ; (i) Rojobot motor control input from system
 000                         CONSTANT PWR_LOCX, 01              ; (o) X coordinate of rojobot location
 000                         CONSTANT PWR_LOCY, 02              ; (o))Y coordinate of rojobot location
 000                         CONSTANT PWR_BOTINFO, 03           ; (o) Rojobot info register
 000                         CONSTANT PWR_SENSORS, 04           ; (o) Sensor register
 000                         CONSTANT PWR_LMDIST, 05            ; (o) Rojobot left motor distance register
 000                         CONSTANT PWR_RMDIST, 06            ; (o) Rojobot right motor distance register
 000                         CONSTANT PRW_RSVD07, 07            ; () **RESERVED**
 000                         ; map logic interface ports
 000                         CONSTANT PWR_COLADR, 08            ; (o) Column address of map location
 000                         CONSTANT PWR_ROWADR, 09            ; (o) Row address of map location
 000                         CONSTANT PRD_LOCINFO, 0A           ; (i) location info from map logic
 000                         CONSTANT PRW_RSVD0B, 0B            ; () **RESERVED**
 000                         ; control signals - implemented as I/O ports w/ no data
 000                         CONSTANT PRW_LOADREGS, 0C          ; (i/o) load system interface registers
 000                         CONSTANT PRW_LDMOTDIST, 0D         ; (i/o) load motor distance counters
 000                         CONSTANT PRW_UPDSYSREGS, 0E        ; (i/o) system registers updated flag
 000                         CONSTANT PRW_RSVD0F, 0F            ; () **RESERVED**
 000                         CONSTANT PRD_CONFIG, 07            ; (i) Rojobot configuration register
 000                         ; =================================
 000                         ; === Scratch Pad RAM Variables ===
 000                         ; =================================
 000                         ; next orientation lookup table - this is a nibble orientated 16 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; high nibble of entry is the next orientation if the rojobot is turning right
 000                         ; low nibble of entry is the next orientation if the rojobot is turning left
 000                         CONSTANT SP_ORTBASE, 00            ; table is based at 0x00
 000                         CONSTANT SP_ORTNO, 17              ; entry N - right is NE, left is NW
 000                         CONSTANT SP_ORTNE, 20              ; entry NE - right is E, left is N
 000                         CONSTANT SP_ORTEA, 31              ; entry E - right is SE, left is NE
 000                         CONSTANT SP_ORTSE, 42              ; entry SE - right is S, left is E
 000                         CONSTANT SP_ORTSO, 53              ; entry S - right is SW, left is SE
 000                         CONSTANT SP_ORTSW, 64              ; entry SW - right is W, left is S
 000                         CONSTANT SP_ORTWE, 75              ; entry W - right is NW, left is SW
 000                         CONSTANT SP_ORTNW, 06              ; entry NW - right is N, left is W
 000                         ; new XY lookup table - this is a byte orientated 8 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; high nibble of entry is the increment to get new x coordinate
 000                         ; low nibble of entry is the increment to get new y coordinate
 000                         ; entry nibble values:  0=increment by 0, 1=increment by 1,
 000                         ; F - decrement by 1 (increment by -1)
 000                         CONSTANT SP_XYTBASE, 10            ; table is based at 0x10
 000                         CONSTANT SP_XYTNO, 0F              ; entry N - X is 0, Y is -1
 000                         CONSTANT SP_XYTNE, 1F              ; entry NE - X is 1, Y is -1
 000                         CONSTANT SP_XYTEA, 10              ; entry E - X is 1, Y is 0
 000                         CONSTANT SP_XYTSE, 11              ; entry SE - X is 1, Y is 1
 000                         CONSTANT SP_XYTSO, 01              ; entry S - X is 0, Y is 1
 000                         CONSTANT SP_XYTSW, F1              ; entry SW - X is -1, Y is 1
 000                         CONSTANT SP_XYTWE, F0              ; entry W - X is -1, Y is 0
 000                         CONSTANT SP_XYTNW, FF              ; entry NW - X is -1, Y is -1
 000                         ; movement lookup table - this is a nibble-oriented 16 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; assumes dir = 1 = FWD, dir = 0 = REV
 000                         CONSTANT SP_MVTBASE, 20            ; table is based at 0x20
 000                         CONSTANT SP_MVT10, 00              ; entry 1,0 - both motors stopped
 000                         CONSTANT SP_MVT32, 00              ; entry 3,2 - both motors stopped
 000                         CONSTANT SP_MVT54, CE              ; entry 5,4 - 5 is SLT, 4 is SRT
 000                         CONSTANT SP_MVT76, CE              ; entry 7,6 - 7 is SLT, 6 is SRT
 000                         CONSTANT SP_MVT98, CC              ; entry 9,8 - 9 is SLT, 8 is SLT
 000                         CONSTANT SP_MVTBA, EE              ; entry B,A - B is SRT, A is SRT
 000                         CONSTANT SP_MVTDC, D8              ; entry D,C - D is FLT, C is REV
 000                         CONSTANT SP_MVTFE, 4F              ; entry F,E - F is FWD, E is FRT
 000                         ; Temp storage
 000                         CONSTANT TEMP1, 3F                 ; Temporary storage addresses
 000                         CONSTANT TEMP2, 3E
 000                         ; Variable motor speed support addresses
 000                         CONSTANT VS_LMTHRSH, 30            ; Left Motor Step threshold (set from CONFIG register)
 000                         CONSTANT VS_RMTHRSH, 31            ; Right Motor Step threshold (set from CONFIG register)
 000                         CONSTANT VS_MOTCMSK, 32            ; Motor control bits mask.  Set to 0x001 for on/off motor control
 000                         ; and 0x111 for variable speed control
 000                         CONSTANT VS_ENVSCTL, 33            ; Enable variable speed motor control flag (0 = on/off control, 1 = variable speed control)
 000                         ; ================================
 000                         ; === Virtual world parameters ===
 000                         ; ================================
 000                         CONSTANT WSIZE_COLS, 80            ; Virtual world has 128 columns (x coordinate)
 000                         CONSTANT WSIZE_ROWS, 80            ; Virtual world has 128 rows (y coordinate)
 000                         ; Change these two values to adjust the speed the rojobot moves in the world
 000                         ; A smaller value will speed up the rojobot and a larger value will slow down the rojobot
 000                         CONSTANT WTHR_LMOT, 02             ; accumulated left motor distance for moving rojobot
 000                         CONSTANT WTHR_RMOT, 02             ; accumulated right motor distance for moving rojobot
 000                         CONSTANT WSTRT_COL, 01             ; initial position for rojobot (col = 128 /2 = 64)
 000                         CONSTANT WSTRT_ROW, 40             ; initial position for rojobot (row = 128 /2 = 64)
 000                         CONSTANT WTYPE_GND, 00             ; location type 0 is bare "ground"
 000                         CONSTANT WTYPE_BLKL, 01            ; location type 1 is black line
 000                         CONSTANT WTYPE_OBSTR, 02           ; location type 2 is obstruction (or boundary wall)
 000                         CONSTANT WTYPE_RSVD, 03            ; location type 3 is reserved
 000                         ; ==========================
 000                         ; === Rojobot parameters ===
 000                         ; ==========================
 000                         CONSTANT DISTCTR_IVAL, 00          ; Initial value for rojobot distance counters
 000                         CONSTANT OR_N, 00                  ; Orientation is North
 000                         CONSTANT OR_NE, 01                 ; Orientation is Northeast
 000                         CONSTANT OR_E, 02                  ; Orientation is East
 000                         CONSTANT OR_SE, 03                 ; Orientation is Southeast
 000                         CONSTANT OR_S, 04                  ; Orientation is South
 000                         CONSTANT OR_SW, 05                 ; Orientation is Southwest
 000                         CONSTANT OR_W, 06                  ; Orientation is West
 000                         CONSTANT OR_NW, 07                 ; Orientation is Northwest
 000                         CONSTANT MV_STOP, 00               ; Movement is stopped
 000                         CONSTANT MV_FWD, 04                ; Movement is forward
 000                         CONSTANT MV_REV, 08                ; Movement is reverse
 000                         CONSTANT MV_SLT, 0C                ; Movement is slow left turn
 000                         CONSTANT MV_FLT, 0D                ; Movement is fast left turn
 000                         CONSTANT MV_SRT, 0E                ; Movement is slow right turn
 000                         CONSTANT MV_FRT, 0F                ; Movement is fast right turn
 000                         ; ====================
 000                         ; === Useful masks ===
 000                         ; ====================
 000                         ; NOTE:  THIS IMPLEMENTATION HAS SPEED CONTROL
 000                         ; ALL THREE SPEED BITS FOR EACH MOTOR ARE INTERPETED BUT THERE IS
 000                         ; AN ASSUMPTION THAT BOTH WHEELS ARE EITHER TURNING AT THE SAME SPEED
 000                         ; OR ARE STOPPED.  THERE IS NO VEER ALGORITHM OR VARiABLE ARCS
 000                         ; motor control register
 000                         CONSTANT MSK_RMBITS, 0F            ; right motor status is MotCtl[3:0]
 000                         CONSTANT MSK_LMBITS, F0            ; left motor status is MotCtl[7:4]
 000                         CONSTANT MSK_MOTR_STS, 0F          ; motor status is in bits[3:0]
 000                         ; DISABLE SPEED CONTROL BY ONLY LOOKING AT LSB - DEFAULT
 000                         CONSTANT MSK_MOTSPD, 01            ; motor speed bits - no speed control
 000                         ; ENABLE SPEED CONTROL BY LOOKING AT ALL 3 SPEED BITS INSTEAD OF JUST LSB
 000                         CONSTANT MSK_VMOTSPD, 07           ; motor speed bits - w/ variable speed control
 000                         ; ==============================
 000                         ; === Other useful constants ===
 000                         ; ==============================
 000                         ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                         ;clock applied to KCPSM6. Every instruction executes in 2 clock cycles making the
 000                         ;calculation highly predictable. The '6' in the following equation even allows for
 000                         ;'CALL delay_1us' instruction in the initiating code.
 000                         ;
 000                         ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                         ;
 000                         ;For our 100MHz clock the constant value is (100 - 6)/4 = 23.5 = 24  (18 Hex).
 000                         ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                         ;become lower than intended.
 000                         ;
 000                         CONSTANT DELAYVAL_1uS, 24'd        ; 1us delay count
 000                         ; ===============
 000                         ; === main()  ===
 000                         ; ===============
 000                         ADDRESS 000
 000                  start: 
 000  22004                  JUMP 004[main]                     ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                     ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                     ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                     ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004                         ;    JUMP test_wrldIF     ; test the world I/F
 004  2004E            main: CALL 04E[init_mvlkuptbl]           ; initialize movement lookup table
 005  2006C                  CALL 06C[init_orlkuptbl]           ; initialize orientation lookup table
 006  200BE                  CALL 0BE[init_xylkuptbl]           ; initialize xy increment lookup table
 007  01F02                  LOAD sF[Orient], 02[OR_E]          ; Position the BOT Stopped and facing East
 008  01E00                  LOAD sE[Mvmnt], 00[MV_STOP]
 009  01D01                  LOAD sD[LocX], 01[WSTRT_COL]       ; in the middle of the world
 00A  01C40                  LOAD sC[LocY], 40[WSTRT_ROW]       ;
 00B  2002A                  CALL 02A[upd_sysregs]              ; Display initial values of system registers
 00C  201CE                  CALL 1CE[init_rojobot]             ; then initialize the Rojobot
 00D  20039                  CALL 039[upd_distregs]             ; Display initial values of motor distance counters
 00E                         ; and enter main emulation loop
 00E                         ; ===========================
 00E                         ; === Main Emulation Loop ===
 00E                         ; ===========================
 00E  09007         emul_lp: INPUT s0, 07[PRD_CONFIG]           ; get BOT configuration from system and save in S0
 00F  201BB                  CALL 1BB[adjthresh]                ; adjust wheel thresholds and masks based on configuration
 010  09000                  INPUT s0, 00[PRD_MOTCTL_IN]        ; get motor controls from "system" and save in s0
 011  201D4                  CALL 1D4[rojobot]                  ; and simulate rojobot
 012                         ; motor status bits are returned in s0
 012  20067                  CALL 067[calc_movement]            ; next calculate the movement-it may have changed
 013  00E00                  LOAD sE[Mvmnt], s0                 ; movement is returned in s0 - save it
 014                         ; Motor distance updated in rojobot()
 014  20039                  CALL 039[upd_distregs]             ; display the motor distance counters
 015  2002A                  CALL 02A[upd_sysregs]              ; next update the system registers
 016  0B030                  FETCH s0, 30[VS_LMTHRSH]           ; Fetch left motor threshold from scratchpad RAM
 017  1C900                  COMPARE s9[LMDist], s0             ; has left motor moved more than the threshold?
 018  3E01D                  JUMP NC, 01D[emul_lp01]            ; yes if CF = 0 need to update the world
 019  1D031                  COMPARE s0, 31[VS_RMTHRSH]         ; Fetch right motor threshold from scratchpad RAM
 01A  1C800                  COMPARE s8[RMDist], s0             ; has right motor moved more than the threshold?
 01B  3E01D                  JUMP NC, 01D[emul_lp01]            ; yes if CF = 0 need to update the world
 01C  22028                  JUMP 028[naptime]                  ; no world update needed - it's nap time
 01D                         ;  update the world starts here - global registers and SP RAM locations are affected
 01D                         ;  see description of individual functions for what registers and memory get changed
 01D  001F0       emul_lp01: LOAD s1, sF[Orient]                ; calculate new orientation based on movement
 01E  002E0                  LOAD s2, sE[Mvmnt]                 ; s1 gets current orientation, s2 gets
 01F  2008A                  CALL 08A[calc_orient]              ; current movement. new orientation is
 020  00F00                  LOAD sF[Orient], s0                ; returned in s0.  Save new orientation
 021  001F0                  LOAD s1, sF[Orient]                ; get the new location coordinates
 022  002E0                  LOAD s2, sE[Mvmnt]                 ; s1 gets current orientation, s2 gets movement
 023  200E0                  CALL 0E0[get_newxy]                ; on return s0 has x coord and s1 has y coord
 024  00D00                  LOAD sD[LocX], s0                  ; and save the new location
 025  00C10                  LOAD sC[LocY], s1
 026  01900                  LOAD s9[LMDist], 00[DISTCTR_IVAL]  ; then clear the left and right
 027  01800                  LOAD s8[RMDist], 00[DISTCTR_IVAL]  ; motor distance counters
 028                         ; nap time - emulation sleeps for 50ms and then starts again
 028  20205         naptime: CALL 205[delay_50ms]               ; software 50ms delay timing loop
 029  2200E                  JUMP 00E[emul_lp]                  ; and start again
 02A                         ;**************************************************************************************
 02A                         ; Support functions
 02A                         ;**************************************************************************************
 02A                         ;*******
 02A                         ; Functions to update system registers
 02A                         ;*******
 02A                         ; =====================================================================
 02A                         ; === upd_sysregs() - updates the system registers                  ===
 02A                         ; === Registers affected: s0, s1, s2,s3, s4, s5, s6, s7             ===
 02A                         ; === Also affects global registers Sensor, Botinf                  ===
 02A                         ; === Uses the rojobot location, orientation, and movement to       ===
 02A                         ; === read the map (for sensors) and build BotInfo register         ===
 02A                         ; === Toggles the "system registers updated" flag                   ===
 02A                         ; =====================================================================
 02A  001D0     upd_sysregs: LOAD s1, sD[LocX]                  ; s1 and s2 get rojobot location
 02B  002C0                  LOAD s2, sC[LocY]                  ; s0 will get new sensor reg value
 02C  20127                  CALL 127[get_sensors]              ; get the new sensor register
 02D  00B00                  LOAD sB[Sensor], s0                ; and save
 02E  201B2                  CALL 1B2[get_botinfo]              ; get the new rojobot info register
 02F  00A00                  LOAD sA[Botinf], s0                ; and save
 030  2DD01                  OUTPUT sD[LocX], 01[PWR_LOCX]      ; update the system interface registers
 031  2DC02                  OUTPUT sC[LocY], 02[PWR_LOCY]      ; these are holding registers in the
 032  2DB04                  OUTPUT sB[Sensor], 04[PWR_SENSORS] ; world_if.v hardware.  The system-visible
 033  2DA03                  OUTPUT sA[Botinf], 03[PWR_BOTINFO] ; registers are updated w/ the
 034  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; LOAD REG signal.  First write toggles to 1
 035  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; Second write toggles to 0
 036  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; toggle the "system registers updated" flag
 037  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; First write togles to 1, second write to 0
 038  25000                  RETURN 
 039                         ; ====================================================================
 039                         ; === upd_distregs() - updates the system motor distance registers ===
 039                         ; === Registers affected: None                                     ===
 039                         ; === Uses the rojobot left and right motor distance registers     ===
 039                         ; ====================================================================
 039  2D905    upd_distregs: OUTPUT s9[LMDist], 05[PWR_LMDIST]  ; Update left and right motor
 03A  2D806                  OUTPUT s8[RMDist], 06[PWR_RMDIST]  ; distance counters
 03B  2D00D                  OUTPUT s0, 0D[PRW_LDMOTDIST]       ; LMOTDIST control signals updates
 03C  2D00D                  OUTPUT s0, 0D[PRW_LDMOTDIST]       ; the system registers - toggle 1 then 0
 03D  25000                  RETURN 
 03E                         ;*******
 03E                         ; Functions to look up values
 03E                         ;*******
 03E                         ; =====================================================================
 03E                         ; === lkup_nib() - looks up an entry in a nibble-based lookup table ===
 03E                         ; === Registers affected: s0, s1, s2                                ===
 03E                         ; === s1 contains the value to lookup,  s2 contains the base        ===
 03E                         ; === address of the table.  entry is returned in low nibble of s0  ===
 03E                         ; =====================================================================
 03E  00010        lkup_nib: LOAD s0, s1                        ; save value to lookup in s0
 03F  1400E                  SR0 s0                             ; 2 entries/byte to divide by 2
 040  10200                  ADD s2, s0                         ; add to table base to get offset
 041  0A020                  FETCH s0, (s2)                     ; and fetch the entry
 042  1410E                  SR0 s1                             ; test if value is even or odd
 043  3E049                  JUMP NC, 049[lkup_nib01]           ; if CY = 1 it's odd entry in table
 044  1400E                  SR0 s0                             ; so shift high nibble to low nibble
 045  1400E                  SR0 s0                             ;
 046  1400E                  SR0 s0                             ;
 047  1400E                  SR0 s0                             ;
 048  25000                  RETURN                             ; and return
 049  0300F      lkup_nib01: AND s0, 0F                         ; entry in low nibble so mask
 04A  25000                  RETURN                             ; out upper nibble and return
 04B                         ; =====================================================================
 04B                         ; === lkup_byte() - looks up an entry in a byte-based lookup table  ===
 04B                         ; === Registers affected: s0, s1, s2                                ===
 04B                         ; === s1 contains the value to lookup,  s2 contains the base        ===
 04B                         ; === address of the table.  entry is returned in s0                ===
 04B                         ; =====================================================================
 04B  10210       lkup_byte: ADD s2, s1                         ; add to table base to get offset
 04C  0A020                  FETCH s0, (s2)                     ; and fetch the entry
 04D  25000                  RETURN 
 04E                         ;*******
 04E                         ; Functions to calculate movement
 04E                         ;*******
 04E                         ; =====================================================================
 04E                         ; === init_mvlkuptbl() - initialize movement lookup table in SP RAM ===
 04E                         ; === Registers affected: s0, s1                                    ===
 04E                         ; =====================================================================
 04E  01020  init_mvlkuptbl: LOAD s0, 20[SP_MVTBASE]            ; s0 gets base of movement lookup table
 04F  01100                  LOAD s1, 00[SP_MVT10]              ; s1 gets values for entries 1 and 0
 050  2E100                  STORE s1, (s0)                     ; store the entry in the table
 051  11001                  ADD s0, 01                         ; increment the table index
 052  01100                  LOAD s1, 00[SP_MVT32]              ; s1 gets values for entries 3 and 2
 053  2E100                  STORE s1, (s0)                     ; store the entry in the table
 054  11001                  ADD s0, 01                         ; increment the table index
 055  011CE                  LOAD s1, CE[SP_MVT54]              ; s1 gets values for entries 5 and 4
 056  2E100                  STORE s1, (s0)                     ; store the entry in the table
 057  11001                  ADD s0, 01                         ; increment the table index
 058  011CE                  LOAD s1, CE[SP_MVT76]              ; s1 gets values for entries 7 and 6
 059  2E100                  STORE s1, (s0)                     ; store the entry in the table
 05A  11001                  ADD s0, 01                         ; increment the table index
 05B  011CC                  LOAD s1, CC[SP_MVT98]              ; s1 gets values for entries 9 and 8
 05C  2E100                  STORE s1, (s0)                     ; store the entry in the table
 05D  11001                  ADD s0, 01                         ; increment the table index
 05E  011EE                  LOAD s1, EE[SP_MVTBA]              ; s1 gets values for entries 11 and 10
 05F  2E100                  STORE s1, (s0)                     ; store the entry in the table
 060  11001                  ADD s0, 01                         ; increment the table index
 061  011D8                  LOAD s1, D8[SP_MVTDC]              ; s1 gets values for entries 13 and 12
 062  2E100                  STORE s1, (s0)                     ; store the entry in the table
 063  11001                  ADD s0, 01                         ; increment the table index
 064  0114F                  LOAD s1, 4F[SP_MVTFE]              ; s1 gets values for entries 15 and 14
 065  2E100                  STORE s1, (s0)                     ; store the entry in the table
 066  25000                  RETURN                             ; done...at last
 067                         ; ===========================================================================
 067                         ; === calc_movement() - uses motor status register bits[3:0] to calculate ===
 067                         ; === the rojobot's movement (fwd, rev, stopped, etc.)                    ===
 067                         ; === Registers affected: s0, s1, s2                                      ===
 067                         ; === s0 contains the contents of motor status reg, result returned in s0 ===
 067                         ; === The calculation is done by looking up the movement in the nibble    ===
 067                         ; === based movement lookup table                                         ===
 067                         ; ===========================================================================
 067  00100   calc_movement: LOAD s1, s0                        ; move motor status to s1
 068  0310F                  AND s1, 0F[MSK_MOTR_STS]           ; isolate the motor on and direction bits
 069  01220                  LOAD s2, 20[SP_MVTBASE]            ; s2 gets base of movement lookup table
 06A  2003E                  CALL 03E[lkup_nib]                 ; look up the movement
 06B  25000                  RETURN                             ; results are returned in s0
 06C                         ;*******
 06C                         ; Functions to calculate orientation
 06C                         ;*******
 06C                         ; ========================================================================
 06C                         ; === init_orlkuptbl() - initialize orientation lookup table in SP RAM ===
 06C                         ; === Registers affected: s0, s1                                       ===
 06C                         ; ========================================================================
 06C  01000  init_orlkuptbl: LOAD s0, 00[SP_ORTBASE]            ; s0 gets base of orientation lookup table
 06D  01117                  LOAD s1, 17[SP_ORTNO]              ; s1 gets values for entries for North
 06E  2E100                  STORE s1, (s0)                     ; store the entry in the table
 06F  11001                  ADD s0, 01                         ; increment the table index
 070  01120                  LOAD s1, 20[SP_ORTNE]              ; s1 gets values for entries Northeast
 071  2E100                  STORE s1, (s0)                     ; store the entry in the table
 072  11001                  ADD s0, 01                         ; increment the table index
 073  01131                  LOAD s1, 31[SP_ORTEA]              ; s1 gets values for entries East
 074  2E100                  STORE s1, (s0)                     ; store the entry in the table
 075  11001                  ADD s0, 01                         ; increment the table index
 076  01142                  LOAD s1, 42[SP_ORTSE]              ; s1 gets values for entries Southeast
 077  2E100                  STORE s1, (s0)                     ; store the entry in the table
 078  11001                  ADD s0, 01                         ; increment the table index
 079  01153                  LOAD s1, 53[SP_ORTSO]              ; s1 gets values for entries South
 07A  2E100                  STORE s1, (s0)                     ; store the entry in the table
 07B  11001                  ADD s0, 01                         ; increment the table index
 07C  01164                  LOAD s1, 64[SP_ORTSW]              ; s1 gets values for entries Southwest
 07D  2E100                  STORE s1, (s0)                     ; store the entry in the table
 07E  11001                  ADD s0, 01                         ; increment the table index
 07F  01175                  LOAD s1, 75[SP_ORTWE]              ; s1 gets values for entries West
 080  2E100                  STORE s1, (s0)                     ; store the entry in the table
 081  11001                  ADD s0, 01                         ; increment the table index
 082  01106                  LOAD s1, 06[SP_ORTNW]              ; s1 gets values for entries Northwest
 083  2E100                  STORE s1, (s0)                     ; store the entry in the table
 084  25000                  RETURN                             ; done...at last
 085                         ; =========================================================================
 085                         ; === next_orient() - selects next orientation                          ===
 085                         ; === Registers affected: s0, s1, s2, s3                                ===
 085                         ; === s1 contains the current orientation, s2 contains the base address ===
 085                         ; === of the table, s3 contains the direction.                          ===
 085                         ; === s3=1 says turning right, s3=0 says turning left, new value is     ===
 085                         ; === returned in s0.                                                   ===
 085                         ; === The calculation is done by looking up the orientation in the      ===
 085                         ; === nibble-based orientation lookup table                             ===
 085                         ; =========================================================================
 085  14106     next_orient: SL0 s1                             ; adjust for 2 entries per orientation
 086  10130                  ADD s1, s3                         ; adjust for left/right turn
 087  01200                  LOAD s2, 00[SP_ORTBASE]            ; s2 gets base of orientation lookup table
 088  2003E                  CALL 03E[lkup_nib]                 ; look up the orientation
 089  25000                  RETURN                             ; results are returned in s0
 08A                         ; ==========================================================================
 08A                         ; === calc_orient() - calculates new orientation                         ===
 08A                         ; === Registers affected: s0, s1, s2, s3, s4, s5                         ===
 08A                         ; === s1 contains the current orientation, s2 contains the current       ===
 08A                         ; === movement.  On return s0 contains new orientation.                  ===
 08A                         ; === s4 and s5 are used as temporary registers                          ===
 08A                         ; === The calculation is done by a switch statment based on the movement ===
 08A                         ; ==========================================================================
 08A  00410     calc_orient: LOAD s4, s1                        ; save the current orientation
 08B  00520                  LOAD s5, s2                        ; save the current movement
 08C                         ; switch (movement) {
 08C  1D500     co_caseSTOP: COMPARE s5, 00[MV_STOP]            ; case(MV_STOP):
 08D  36091                  JUMP NZ, 091[co_caseFWD]           ;
 08E  00040                  LOAD s0, s4                        ;  s0 = current orientation
 08F  01004                  LOAD s0, 04[OR_S]
 090  220BD                  JUMP 0BD[co_endcase]               ;
 091                         ;
 091  1D504      co_caseFWD: COMPARE s5, 04[MV_FWD]             ; case (MV_FWD):
 092  36095                  JUMP NZ, 095[co_caseREV]           ;
 093  00040                  LOAD s0, s4                        ;  s0 = current orientation
 094  220BD                  JUMP 0BD[co_endcase]               ;
 095                         ;
 095  1D508      co_caseREV: COMPARE s5, 08[MV_REV]             ; case (MV_REV):
 096  3609A                  JUMP NZ, 09A[co_caseSLT]           ;
 097  00040                  LOAD s0, s4                        ;  s0 = current orientation
 098  01004                  LOAD s0, 04[OR_S]
 099  220BD                  JUMP 0BD[co_endcase]               ;
 09A                         ;
 09A  1D50C      co_caseSLT: COMPARE s5, 0C[MV_SLT]             ; case (MV_SLT):
 09B  360A1                  JUMP NZ, 0A1[co_caseFLT]           ;
 09C  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 09D  01300                  LOAD s3, 00                        ;    current orientation
 09E  20085                  CALL 085[next_orient]              ;     turning left)
 09F  01002                  LOAD s0, 02[OR_E]
 0A0  220BD                  JUMP 0BD[co_endcase]               ;
 0A1                         ;
 0A1  1D50D      co_caseFLT: COMPARE s5, 0D[MV_FLT]             ; case (MV_FLT):
 0A2  360AB                  JUMP NZ, 0AB[co_caseSRT]           ;
 0A3  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 0A4  01300                  LOAD s3, 00                        ;    current orientation
 0A5  20085                  CALL 085[next_orient]              ;     turning left)
 0A6  00100                  LOAD s1, s0                        ;   s0 = next_orient(
 0A7  01300                  LOAD s3, 00                        ;    current orientation
 0A8  20085                  CALL 085[next_orient]              ;     turning left)
 0A9  01002                  LOAD s0, 02[OR_E]
 0AA  220BD                  JUMP 0BD[co_endcase]               ;
 0AB                         ;
 0AB  1D50E      co_caseSRT: COMPARE s5, 0E[MV_SRT]             ; case (MV_SRT):
 0AC  360B2                  JUMP NZ, 0B2[co_caseFRT]           ;
 0AD  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 0AE  01301                  LOAD s3, 01                        ;    current orientation
 0AF  20085                  CALL 085[next_orient]              ;     turning right)
 0B0  01006                  LOAD s0, 06[OR_W]
 0B1  220BD                  JUMP 0BD[co_endcase]               ;
 0B2                         ;
 0B2  1D50F      co_caseFRT: COMPARE s5, 0F[MV_FRT]             ; case (MV_FRT):
 0B3  360BC                  JUMP NZ, 0BC[co_caseDFLT]          ;
 0B4  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 0B5  01301                  LOAD s3, 01                        ;    current orientation
 0B6  20085                  CALL 085[next_orient]              ;     turning right)
 0B7  00100                  LOAD s1, s0                        ;   s0 = next_orient(
 0B8  01301                  LOAD s3, 01                        ;    current orientation
 0B9  20085                  CALL 085[next_orient]              ;     turning right)
 0BA  01006                  LOAD s0, 06[OR_W]
 0BB  220BD                  JUMP 0BD[co_endcase]               ;
 0BC                         ;
 0BC  00040     co_caseDFLT: LOAD s0, s4                        ; default:
 0BD                         ;   s0 = current_orientation
 0BD  25000      co_endcase: RETURN                             ; return new orientation in s0
 0BE                         ;*******
 0BE                         ; Functions to calculate new location coordinates
 0BE                         ;*******
 0BE                         ; =====================================================================
 0BE                         ; === init_xylkuptbl() - initialize xy incr  lookup table in SP RAM ===
 0BE                         ; === Registers affected: s0, s1                                    ===
 0BE                         ; =====================================================================
 0BE  01010  init_xylkuptbl: LOAD s0, 10[SP_XYTBASE]            ; s0 gets base of xy increment lookup table
 0BF  0110F                  LOAD s1, 0F[SP_XYTNO]              ; s1 gets values for entries for North
 0C0  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C1  11001                  ADD s0, 01                         ; increment the table index
 0C2  0111F                  LOAD s1, 1F[SP_XYTNE]              ; s1 gets values for entries Northeast
 0C3  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C4  11001                  ADD s0, 01                         ; increment the table index
 0C5  01110                  LOAD s1, 10[SP_XYTEA]              ; s1 gets values for entries East
 0C6  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C7  11001                  ADD s0, 01                         ; increment the table index
 0C8  01111                  LOAD s1, 11[SP_XYTSE]              ; s1 gets values for entries Southeast
 0C9  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0CA  11001                  ADD s0, 01                         ; increment the table index
 0CB  01101                  LOAD s1, 01[SP_XYTSO]              ; s1 gets values for entries South
 0CC  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0CD  11001                  ADD s0, 01                         ; increment the table index
 0CE  011F1                  LOAD s1, F1[SP_XYTSW]              ; s1 gets values for entries Southwest
 0CF  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0D0  11001                  ADD s0, 01                         ; increment the table index
 0D1  011F0                  LOAD s1, F0[SP_XYTWE]              ; s1 gets values for entries West
 0D2  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0D3  11001                  ADD s0, 01                         ; increment the table index
 0D4  011FF                  LOAD s1, FF[SP_XYTNW]              ; s1 gets values for entries Northwest
 0D5  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0D6  25000                  RETURN                             ; done...at last
 0D7                         ; =========================================================================
 0D7                         ; === next_xy() - returns x and y increment values for next location    ===
 0D7                         ; === Registers affected: s0, s1, s2, s3                                ===
 0D7                         ; === s1 contains the current orientation, s2 contains the base address ===
 0D7                         ; === of the table.  The x increment is returned in s0 and the y        ===
 0D7                         ; === increment is returned in s1                                       ===
 0D7                         ; === The calculation is done by looking up the increments in the       ===
 0D7                         ; === byte-based xy lookup table.  The x increment is in the upper      ===
 0D7                         ; === nibble and the y increment is in the lower nibble of the entries  ===
 0D7                         ; =========================================================================
 0D7  01210         next_xy: LOAD s2, 10[SP_XYTBASE]            ; s2 gets base of xy increment lookup table
 0D8  2004B                  CALL 04B[lkup_byte]                ; look up the orientation
 0D9  00100                  LOAD s1, s0                        ; s1 gets copy of results
 0DA  0310F                  AND s1, 0F                         ; low nibble is y increment
 0DB  1400E                  SR0 s0                             ; shift s0 x 4 to move
 0DC  1400E                  SR0 s0                             ; high nibble down
 0DD  1400E                  SR0 s0                             ;
 0DE  1400E                  SR0 s0                             ;
 0DF  25000                  RETURN                             ; return
 0E0                         ; =========================================================================
 0E0                         ; === get_newxy() - returns x and y coordinates for new Rojobot location===
 0E0                         ; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                ===
 0E0                         ; === s1 contains the crnt orientation, s2 contains the crnt movement   ===
 0E0                         ; === The new x location is returned in s0 and the new y location       ===
 0E0                         ; === is returned in s1.                                                ===
 0E0                         ; === The rojobot only changes location when it is moving forward or    ===
 0E0                         ; === backward and if the location it is moving into is not obstructed. ===
 0E0                         ; ===                                                                   ===
 0E0                         ; === The function will not move the Rojobot onto an obstructed         ===
 0E0                         ; === location.                                                         ===
 0E0                         ; =========================================================================
 0E0  00420       get_newxy: LOAD s4, s2                        ; save crnt movement - s2 will change
 0E1  00510                  LOAD s5, s1                        ; save crnt orientation - s1 will change
 0E2  09D01                  INPUT sD[LocX], 01[PWR_LOCX]       ; Pulls LocX from interface for override. - Sidescroller
 0E3  09C02                  INPUT sC[LocY], 02[PWR_LOCY]       ; Pulls LocY from interface for override. - Sidescroller
 0E4  006D0                  LOAD s6, sD[LocX]                  ; save current x coordinate in s6
 0E5  007C0                  LOAD s7, sC[LocY]                  ; save current y location in s7
 0E6  200D7                  CALL 0D7[next_xy]                  ; s1 contains the orientation
 0E7                         ; on return s0 has x incr, s1 has y incr
 0E7                         ; incr = 0 or 1 or if F incr is -1
 0E7                         ;
 0E7  1D404                  COMPARE s4, 04[MV_FWD]             ;  if (Mvmnt == FWD)  {
 0E8  360F4                  JUMP NZ, 0F4[gnxy_SLT]             ; -- Z != 0 says not FWD, check if SS
 0E9  1D00F                  COMPARE s0, 0F                     ;  if (xcoord == 0x0F)
 0EA  360ED                  JUMP NZ, 0ED[gnxy_01]              ; -- Z != says xcoord != 0F
 0EB  19601                  SUB s6, 01                         ;   newx = LocX - 1
 0EC  220EE                  JUMP 0EE[gnxy_02]                  ;  else
 0ED  10600         gnxy_01: ADD s6, s0                         ;   newx = LocX + incr (either 0 or 1)
 0EE  1D10F         gnxy_02: COMPARE s1, 0F                     ;  if (ycoord = 0x0F)
 0EF  360F2                  JUMP NZ, 0F2[gnxy_03]              ;   newy = LocY -1
 0F0  19701                  SUB s7, 01                         ;
 0F1  22117                  JUMP 117[gnxy_chk0B]               ;  else
 0F2  10710         gnxy_03: ADD s7, s1                         ;   newy = LocY + incr (either 0 or 1)
 0F3  22117                  JUMP 117[gnxy_chk0B]               ; }  // end Mvmnt == FWD
 0F4                         ; =========================================================================
 0F4                         ; === Added for Sidescroller
 0F4                         ; =========================================================================
 0F4  1D40C        gnxy_SLT: COMPARE s4, 0C[MV_SLT]             ; else if (Mvmnt == SLT)  {
 0F5  320FC                  JUMP Z, 0FC[gnxy_11]               ;
 0F6  1D40D                  COMPARE s4, 0D[MV_FLT]             ; else if (Mvmnt == FLT)  {
 0F7  320FC                  JUMP Z, 0FC[gnxy_11]               ;
 0F8  1D40E                  COMPARE s4, 0E[MV_SRT]             ; else if (Mvmnt == SRT)  {
 0F9  320FC                  JUMP Z, 0FC[gnxy_11]               ;
 0FA  1D40C                  COMPARE s4, 0C[MV_SLT]             ; else if (Mvmnt == SLT)  {
 0FB  36107                  JUMP NZ, 107[gnxy_00]              ;   if none of them jump to reverse
 0FC  1D00F         gnxy_11: COMPARE s0, 0F                     ;  if (xcoord == 0x0F)
 0FD  36100                  JUMP NZ, 100[gnxy_08]              ; -- Z != says xcoord != 0F
 0FE  19601                  SUB s6, 01                         ;   newx = LocX - 1
 0FF  22101                  JUMP 101[gnxy_09]                  ;  else
 100  10600         gnxy_08: ADD s6, s0                         ;   newx = LocX + incr (either 0 or 1)
 101  1D10F         gnxy_09: COMPARE s1, 0F                     ;  if (ycoord = 0x0F)
 102  36105                  JUMP NZ, 105[gnxy_10]              ;   newy = LocY -1
 103  19701                  SUB s7, 01                         ;
 104  22117                  JUMP 117[gnxy_chk0B]               ;  else
 105  10710         gnxy_10: ADD s7, s1                         ;   newy = LocY + incr (either 0 or 1)
 106  22117                  JUMP 117[gnxy_chk0B]               ; }  // end Mvmnt == FWD
 107                         ; =========================================================================
 107  1D408         gnxy_00: COMPARE s4, 08[MV_REV]             ; else if (Mvmnt == REV)  {
 108  36114                  JUMP NZ, 114[gnxy_nofwdrev]        ; -- Z != says not REV so position won't change
 109  1D00F                  COMPARE s0, 0F                     ;  if (xcoord == 0x0F)
 10A  3610D                  JUMP NZ, 10D[gnxy_04]              ;
 10B  11601                  ADD s6, 01                         ;   newx = LocX + 1
 10C  2210E                  JUMP 10E[gnxy_05]                  ;  else
 10D  18600         gnxy_04: SUB s6, s0                         ;   newx = LocX - incr (either 0 or 1)
 10E  1D10F         gnxy_05: COMPARE s1, 0F                     ;  if (ycoord == 0x0F)
 10F  36112                  JUMP NZ, 112[gnxy_06]              ;
 110  11701                  ADD s7, 01                         ;   newy = LocY + 1
 111  22117                  JUMP 117[gnxy_chk0B]               ;  else
 112  18710         gnxy_06: SUB s7, s1                         ;   newy = LocY - incr (either 0 or 1)
 113  22117                  JUMP 117[gnxy_chk0B]               ; } // end Mvmnt == REV
 114  00060   gnxy_nofwdrev: LOAD s0, s6                        ;  Not forward or reverse so return current X and Y
 115  00170                  LOAD s1, s7                        ;
 116  25000                  RETURN                             ;
 117                         ;
 117  00160      gnxy_chk0B: LOAD s1, s6                        ; Check if new location is obstructed
 118  00270                  LOAD s2, s7                        ; s1 = newx,  s2 = new y
 119  20122                  CALL 122[get_mapvalue]             ; s0 = value of Map location on return
 11A  1D002                  COMPARE s0, 02[WTYPE_OBSTR]        ; if (Map(x,y) == OBSTR)  {
 11B  3611F                  JUMP NZ, 11F[gnxy_07]              ; -- Z != 1 says location is not obstructed
 11C  000D0                  LOAD s0, sD[LocX]                  ;    s0 = old location (x)
 11D  001C0                  LOAD s1, sC[LocY]                  ;  s1 = old location (y)
 11E  25000                  RETURN                             ;  return
 11F                         ; }
 11F  00060         gnxy_07: LOAD s0, s6                        ; else  {
 120  00170                  LOAD s1, s7                        ;  s0 = newx; s1 = newy;
 121  25000                  RETURN                             ;  return
 122                         ;*******
 122                         ; Functions to manipulate world map
 122                         ;*******
 122                         ; =============================================================================
 122                         ; === get_mapvalue() - returns the value of map location                    ===
 122                         ; === Registers affected: s0, s1, s2                                        ===
 122                         ; === s1 contains the x (col) coordinate and s2 contains the y coordinate   ===
 122                         ; === of the location to access.  the map value for that location is        ===
 122                         ; === returns in s0.                                                        ===
 122                         ; =============================================================================
 122  2D108    get_mapvalue: OUTPUT s1, 08[PWR_COLADR]          ; send column address to map logic
 123  2D209                  OUTPUT s2, 09[PWR_ROWADR]          ; send row address to map logic
 124  00000                  LOAD s0, s0                        ; NOP to give memory plenty of time for read
 125  0900A                  INPUT s0, 0A[PRD_LOCINFO]          ; and get results from map memory
 126  25000                  RETURN                             ; all done
 127                         ;*******
 127                         ; Functions to generate the external registers
 127                         ;*******
 127                         ; =============================================================================
 127                         ; === get_sensors() - returns the value of the sensor register              ===
 127                         ; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                    ===
 127                         ; === s1 contains the x (col) coordinate, s2 contains the y coordinate      ===
 127                         ; === of the location to access.  The global register Orient contains the   ===
 127                         ; === BOT's orientation. The new sensor register value is returned in s0.   ===
 127                         ; =============================================================================
 127                         ; switch(Orient)  {
 127  001D0     get_sensors: LOAD s1, sD[LocX]                  ; get_mapvalue(LocX, LocY)
 128  002C0                  LOAD s2, sC[LocY]                  ;
 129  20122                  CALL 122[get_mapvalue]             ; s0 = map(LocX, LocY)
 12A  00700                  LOAD s7, s0                        ; s7 gets map(LocX, Loc)
 12B  1DF00      gs_caseORN: COMPARE sF[Orient], 00[OR_N]       ; case(OR_N):
 12C  36139                  JUMP NZ, 139[gs_caseORNE]          ;
 12D  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY-1)
 12E  19201                  SUB s2, 01                         ;
 12F  20122                  CALL 122[get_mapvalue]             ;
 130  00400                  LOAD s4, s0                        ;
 131  11101                  ADD s1, 01                         ;   s5 = gets map(LocX, LocY-1)
 132  20122                  CALL 122[get_mapvalue]             ;
 133  00500                  LOAD s5, s0                        ;
 134  11101                  ADD s1, 01                         ;   s6 = gets map(LocX+1, LocY-1)
 135  20122                  CALL 122[get_mapvalue]             ;
 136  00600                  LOAD s6, s0                        ;
 137  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 138  25000                  RETURN                             ;  continue;
 139                         ;
 139  1DF01     gs_caseORNE: COMPARE sF[Orient], 01[OR_NE]      ; case (OR_NE):
 13A  36147                  JUMP NZ, 147[gs_caseORE]           ;
 13B  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY-2)
 13C  19202                  SUB s2, 02                         ;
 13D  20122                  CALL 122[get_mapvalue]             ;
 13E  00400                  LOAD s4, s0                        ;
 13F  11201                  ADD s2, 01                         ;   s5 = gets map(LocX+1, LocY-1)
 140  20122                  CALL 122[get_mapvalue]             ;
 141  00500                  LOAD s5, s0                        ;
 142  11101                  ADD s1, 01                         ;   s6 = gets map(LocX+2, LocY-1)
 143  20122                  CALL 122[get_mapvalue]             ;
 144  00600                  LOAD s6, s0                        ;
 145  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 146  25000                  RETURN 
 147  1DF02      gs_caseORE: COMPARE sF[Orient], 02[OR_E]       ; case (OR_E):
 148  36155                  JUMP NZ, 155[gs_caseORSE]          ;
 149  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY-1)
 14A  19201                  SUB s2, 01                         ;
 14B  20122                  CALL 122[get_mapvalue]             ;
 14C  00400                  LOAD s4, s0                        ;
 14D  11201                  ADD s2, 01                         ;   s5 = gets map(LocX+1, LocY)
 14E  20122                  CALL 122[get_mapvalue]             ;
 14F  00500                  LOAD s5, s0                        ;
 150  11201                  ADD s2, 01                         ;   s6 = gets map(LocX+1, LocY+1)
 151  20122                  CALL 122[get_mapvalue]             ;
 152  00600                  LOAD s6, s0                        ;
 153  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 154  25000                  RETURN 
 155  1DF03     gs_caseORSE: COMPARE sF[Orient], 03[OR_SE]      ; case (OR_SE):
 156  36163                  JUMP NZ, 163[gs_caseORS]           ;
 157  11102                  ADD s1, 02                         ;   s4 = gets map(LocX+2, LocY+1)
 158  11201                  ADD s2, 01                         ;
 159  20122                  CALL 122[get_mapvalue]             ;
 15A  00400                  LOAD s4, s0                        ;
 15B  19101                  SUB s1, 01                         ;   s5 = gets map(LocX+1, LocY+1)
 15C  20122                  CALL 122[get_mapvalue]             ;
 15D  00500                  LOAD s5, s0                        ;
 15E  11201                  ADD s2, 01                         ;   s6 = gets map(LocX+1, LocY+2)
 15F  20122                  CALL 122[get_mapvalue]             ;
 160  00600                  LOAD s6, s0                        ;
 161  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 162  25000                  RETURN 
 163  1DF04      gs_caseORS: COMPARE sF[Orient], 04[OR_S]       ; case (OR_S):
 164  36171                  JUMP NZ, 171[gs_caseORSW]          ;
 165  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY+1)
 166  11201                  ADD s2, 01                         ;
 167  20122                  CALL 122[get_mapvalue]             ;
 168  00400                  LOAD s4, s0                        ;
 169  19101                  SUB s1, 01                         ;   s5 = gets map(LocX, LocY+1)
 16A  20122                  CALL 122[get_mapvalue]             ;
 16B  00500                  LOAD s5, s0                        ;
 16C  19101                  SUB s1, 01                         ;   s6 = gets map(LocX-1, LocY+1)
 16D  20122                  CALL 122[get_mapvalue]             ;
 16E  00600                  LOAD s6, s0                        ;
 16F  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 170  25000                  RETURN 
 171  1DF05     gs_caseORSW: COMPARE sF[Orient], 05[OR_SW]      ; case (OR_SW):
 172  3617F                  JUMP NZ, 17F[gs_caseORW]           ;
 173  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY+2)
 174  11202                  ADD s2, 02                         ;
 175  20122                  CALL 122[get_mapvalue]             ;
 176  00400                  LOAD s4, s0                        ;
 177  19201                  SUB s2, 01                         ;   s5 = gets map(LocX-1, LocY+1)
 178  20122                  CALL 122[get_mapvalue]             ;
 179  00500                  LOAD s5, s0                        ;
 17A  19101                  SUB s1, 01                         ;   s6 = gets map(LocX-2, LocY+1)
 17B  20122                  CALL 122[get_mapvalue]             ;
 17C  00600                  LOAD s6, s0                        ;
 17D  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 17E  25000                  RETURN 
 17F  1DF06      gs_caseORW: COMPARE sF[Orient], 06[OR_W]       ; case (OR_W):
 180  3618D                  JUMP NZ, 18D[gs_caseORNW]          ;
 181  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY+1)
 182  11201                  ADD s2, 01                         ;
 183  20122                  CALL 122[get_mapvalue]             ;
 184  00400                  LOAD s4, s0                        ;
 185  19201                  SUB s2, 01                         ;   s5 = gets map(LocX-1, LocY)
 186  20122                  CALL 122[get_mapvalue]             ;
 187  00500                  LOAD s5, s0                        ;
 188  19201                  SUB s2, 01                         ;   s6 = gets map(LocX-1, LocY-1)
 189  20122                  CALL 122[get_mapvalue]             ;
 18A  00600                  LOAD s6, s0                        ;
 18B  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 18C  25000                  RETURN 
 18D  1DF07     gs_caseORNW: COMPARE sF[Orient], 07[OR_NW]      ; case (OR_NW):
 18E  3619B                  JUMP NZ, 19B[gs_errcase]           ;
 18F  19102                  SUB s1, 02                         ;   s4 = gets map(LocX-2, LocY-1)
 190  19201                  SUB s2, 01                         ;
 191  20122                  CALL 122[get_mapvalue]             ;
 192  00400                  LOAD s4, s0                        ;
 193  11101                  ADD s1, 01                         ;   s5 = gets map(LocX-1, LocY-1)
 194  20122                  CALL 122[get_mapvalue]             ;
 195  00500                  LOAD s5, s0                        ;
 196  19201                  SUB s2, 01                         ;   s6 = gets map(LocX-1, LocY-2)
 197  20122                  CALL 122[get_mapvalue]             ;
 198  00600                  LOAD s6, s0                        ;
 199  2019D                  CALL 19D[set_senvalues]            ;  s0 = new sensor value
 19A  25000                  RETURN 
 19B  010FF      gs_errcase: LOAD s0, FF                        ; error case - should never get here,
 19C  25000                  RETURN                             ; so return illegal value
 19D                         ; ==============================================================================
 19D                         ; === set_senvalues() - sets sensor values based on the locations around bot ===
 19D                         ; === Registers used:  s4,s5,s6 s7.  Registers affected s0                   ===
 19D                         ; === s4, s5, and s6 contain location type for the left front, center front, ===
 19D                         ; === and right front of the bot.  s7 contains location type for the bot's   ===
 19D                         ; === current location of the bot.  The results are returned in s0           ===
 19D                         ; ==============================================================================
 19D  00070   set_senvalues: LOAD s0, s7                        ; Put the current world location type into bits[7:6]
 19E  14006                  SL0 s0                             ;
 19F  14006                  SL0 s0                             ;
 1A0  14006                  SL0 s0                             ;
 1A1  14006                  SL0 s0                             ;
 1A2  14006                  SL0 s0                             ;
 1A3  14006                  SL0 s0                             ;
 1A4  05007                  OR s0, 07                          ; assume theres no black line and no obstructions
 1A5                         ;
 1A5  1D701                  COMPARE s7, 01[WTYPE_BLKL]         ; if (s7 == Black Line) //crnt loc = black line
 1A6  361A8                  JUMP NZ, 1A8[setsen_L0]            ; -- Z = 0 says no match
 1A7  030F8                  AND s0, F8                         ; BlackLine = 000
 1A8  1D502       setsen_L0: COMPARE s5, 02[WTYPE_OBSTR]        ; if (s5 == OBSTR)   // center front = obstruction
 1A9  361AB                  JUMP NZ, 1AB[setsen_L1]            ; --Z = 0 says no match
 1AA  05018                  OR s0, 18                          ; ProxL = ProxR = 1
 1AB  1D402       setsen_L1: COMPARE s4, 02[WTYPE_OBSTR]        ; if (s4 == OBSTR)  // left front = obstruction
 1AC  361AE                  JUMP NZ, 1AE[setsen_L2]            ; --Z=0 says no match
 1AD  05010                  OR s0, 10                          ; ProxL = 1
 1AE  1D602       setsen_L2: COMPARE s6, 02[WTYPE_OBSTR]        ; if (s6 == OBSTR)  // right front = obstruction
 1AF  361B1                  JUMP NZ, 1B1[setsen_L3]            ; --Z=0 says no macth
 1B0  05008                  OR s0, 08                          ; ProxR = 1
 1B1  25000       setsen_L3: RETURN 
 1B2                         ; =============================================================================
 1B2                         ; === get_botinfo() - returns the value of the BOT info register            ===
 1B2                         ; === Registers affected: s0, s1                                            ===
 1B2                         ; === Uses the global registers "Mvmnt" and "Orient"                        ===
 1B2                         ; === new botinfo register value is returned in s0.                         ===
 1B2                         ; =============================================================================
 1B2  000E0     get_botinfo: LOAD s0, sE[Mvmnt]                 ; copy current movement to s0
 1B3  14006                  SL0 s0                             ; and shift it to bit 4
 1B4  14006                  SL0 s0                             ;
 1B5  14006                  SL0 s0                             ;
 1B6  14006                  SL0 s0                             ;
 1B7  001F0                  LOAD s1, sF[Orient]                ; copy current orientation to s1
 1B8  03107                  AND s1, 07                         ; mask out all but lower three bits
 1B9  04010                  OR s0, s1                          ; and OR with Mvmnt contents
 1BA  25000                  RETURN 
 1BB                         ;*******
 1BB                         ; Functions to implement Rojobot
 1BB                         ;*******
 1BB                         ; =====================================================================
 1BB                         ; === adjthresh() - adjusts paramenters based on BOT configuration  ===
 1BB                         ; === Registers affected: s0, s1 and VS_ scratch RAM variables      ===
 1BB                         ; === Assumes BOT configuration is in s0                            ===
 1BB                         ; =====================================================================
 1BB  01100       adjthresh: LOAD s1, 00                        ; Assume on/off control
 1BC  2F133    adjthr_onoff: STORE s1, 33[VS_ENVSCTL]           ; mode = 00 (on/off control)
 1BD  01101                  LOAD s1, 01[MSK_MOTSPD]            ;
 1BE  2F132                  STORE s1, 32[VS_MOTCMSK]           ; motor control mask = 01 - only look at low order bit
 1BF  01102                  LOAD s1, 02[WTHR_LMOT]             ; left motor threshold = default for on/off
 1C0  2F130                  STORE s1, 30[VS_LMTHRSH]           ;
 1C1  01102                  LOAD s1, 02[WTHR_RMOT]             ; right motor threshold = default for on/off
 1C2  2F131                  STORE s1, 31[VS_RMTHRSH]           ;
 1C3                         ; Now check mode and adjust parameters if variable speed enabled
 1C3  1400E                  SR0 s0                             ; move mode (on/off or variable speed) to C
 1C4  3D000                  RETURN NC                          ; CF=0 says that mode is on/off so nothing to do
 1C5                         ;
 1C5  01101       adjthr_vs: LOAD s1, 01                        ; otherwise set mode to variable speed
 1C6  2F133                  STORE s1, 33[VS_ENVSCTL]           ;
 1C7  01107                  LOAD s1, 07[MSK_VMOTSPD]           ; motor control mask = 07 - look at all three motor speed bits
 1C8  2F132                  STORE s1, 32[VS_MOTCMSK]           ;
 1C9  00100                  LOAD s1, s0                        ; left and right motor thresholds = bits[4:0]
 1CA  0311F                  AND s1, 1F                         ;
 1CB  2F130                  STORE s1, 30[VS_LMTHRSH]           ; left and right motor thresholds are the same in this version
 1CC  2F131                  STORE s1, 31[VS_RMTHRSH]           ; of the Rojobot configuration register
 1CD  25000                  RETURN 
 1CE                         ; =====================================================================
 1CE                         ; === init_rojobot() - initialize the rojobot                       ===
 1CE                         ; === Registers affected: LMDist, RMDist, Sensor, and Botinf        ===
 1CE                         ; === Assumes Orientation and Movement has already been initialized ===
 1CE                         ; =====================================================================
 1CE  01900    init_rojobot: LOAD s9[LMDist], 00[DISTCTR_IVAL]  ; initialize left and right
 1CF  01800                  LOAD s8[RMDist], 00[DISTCTR_IVAL]  ; motor distance counters
 1D0  01B00                  LOAD sB[Sensor], 00                ; initialize sensors to 0
 1D1  201B2                  CALL 1B2[get_botinfo]              ; initialize BotInfo register
 1D2  00A00                  LOAD sA[Botinf], s0                ;
 1D3  25000                  RETURN 
 1D4                         ; =====================================================================
 1D4                         ; === rojobot() - simulate the rojobot                              ===
 1D4                         ; === Registers affected: LMDist, RMDist, s0, s1, s2, s3            ===
 1D4                         ; === Functions looks at MotCtl and adjusts the distance counters   ===
 1D4                         ; === based on what each of the motors is doing.  Matches motor     ===
 1D4                         ; === speeds by making slower motor move faster.  Returns motor     ===
 1D4                         ; === status (lm_on, rm_on, lm_dir, rm_dir) in s0 for use by the    ===
 1D4                         ; === calc_movement() function.  MotCtl is passed in s0             ===
 1D4                         ; =====================================================================
 1D4  00100         rojobot: LOAD s1, s0                        ; s1[3:0] gets right motor control
 1D5  0310F                  AND s1, 0F[MSK_RMBITS]             ;
 1D6  00200                  LOAD s2, s0                        ; s2[3:0] gets left motor control
 1D7  1420E                  SR0 s2                             ; after you shift it down 4 bits
 1D8  1420E                  SR0 s2                             ;
 1D9  1420E                  SR0 s2                             ;
 1DA  1420E                  SR0 s2                             ;
 1DB                         ; Handle the motor direction bits
 1DB  1410E                  SR0 s1                             ; put rm_dir into carry-bit
 1DC  14008                  SRA s0                             ; and move it to s0[7] to
 1DD                         ; start building motor status
 1DD  1420E                  SR0 s2                             ; put lm_dir into carry-bit
 1DE  14008                  SRA s0                             ; and shift it into place
 1DF  1400E                  SR0 s0                             ; set rm_on and lm_on to "off" by shifting zeros into bits[7:6]
 1E0  1400E                  SR0 s0                             ; the shift also moves lm_dir and rm_dir into bits[5:4]
 1E1                         ;
 1E1                         ; Isolate the speed bits
 1E1  0B332                  FETCH s3, 32[VS_MOTCMSK]           ; Load the speed bit mask
 1E2  02130                  AND s1, s3                         ; mask out right motor speed
 1E3  02230                  AND s2, s3                         ; mask out left motor speed
 1E4                         ;
 1E4  1D100                  COMPARE s1, 00                     ; Is the right motor moving?
 1E5  321EB                  JUMP Z, 1EB[rojobot_01]            ; --ZF is 1 says right motor speed == 0
 1E6  1C120                  COMPARE s1, s2                     ; right motor is moving. Is right motor speed < left motor speed?
 1E7  3E1E9                  JUMP NC, 1E9[rojobot_02]           ; --CF is 0 says right motor speed >= left motor speed
 1E8  00120                  LOAD s1, s2                        ; right motor speed < left motor speed so speed up right motor
 1E9  10810      rojobot_02: ADD s8[RMDist], s1                 ; update right motor distance ctr
 1EA  05040                  OR s0, 40                          ; and set rm_spd to "on" (1)
 1EB                         ; motor status = rm_on, lm_dir, rm_dir xxxxx
 1EB                         ;
 1EB  1D200      rojobot_01: COMPARE s2, 00                     ; Is the left motor moving?
 1EC  321F2                  JUMP Z, 1F2[rojobot_03]            ; --ZF is 1 says left motor speed == 0
 1ED  1C210                  COMPARE s2, s1                     ; left motor is moving.  Is left motor speed < right motor speed?
 1EE  3E1F0                  JUMP NC, 1F0[rojobot_04]           ; -- CF is 0 says left motor speed >- right motor speed
 1EF  00210                  LOAD s2, s1                        ; left motor speed < right motor speed so speed up left motor
 1F0  10920      rojobot_04: ADD s9[LMDist], s2                 ; yst it's moving - update distance ctr
 1F1  05080                  OR s0, 80                          ; and set lm_spd to "on" (1)
 1F2  1400E      rojobot_03: SR0 s0                             ; almost done - move motor status
 1F3  1400E                  SR0 s0                             ; to bits [3:0]
 1F4  1400E                  SR0 s0                             ;
 1F5  1400E                  SR0 s0                             ;
 1F6  25000                  RETURN 
 1F7                         ;**************************************************************************************
 1F7                         ; Software delay routines  (Courtesy Ken Chapman - Xilinx Corp)
 1F7                         ;**************************************************************************************
 1F7                         ; ========================================================
 1F7                         ; === delay_1us() - delays execution for 1 microsecond ===
 1F7                         ; === Registers affected: s0                           ===
 1F7                         ; ========================================================
 1F7  01018       delay_1us: LOAD s0, 18[DELAYVAL_1uS]          ; Load 1us delay constant
 1F8  19001        wait_1us: SUB s0, 01                         ; count down to 0
 1F9  361F8                  JUMP NZ, 1F8[wait_1us]             ; and then return
 1FA  25000                  RETURN 
 1FB                         ; ===========================================================
 1FB                         ; === delay_40us() - delays execution for 40 microseconds ===
 1FB                         ; === Registers affected: s0, s1                          ===
 1FB                         ; ===========================================================
 1FB  01128      delay_40us: LOAD s1, 28                        ; 40 x 1us = 40us
 1FC  201F7       wait_40us: CALL 1F7[delay_1us]                ; delay 1us
 1FD  19101                  SUB s1, 01                         ; count down to 0
 1FE  361FC                  JUMP NZ, 1FC[wait_40us]            ; and then return
 1FF  25000                  RETURN 
 200                         ; ========================================================
 200                         ; === delay_1 ms() - delays execution for 1 milisecond ===
 200                         ; === Registers affected: s0, s1, s2                   ===
 200                         ; ========================================================
 200  01219       delay_1ms: LOAD s2, 19                        ; 25 x 40us = 1ms
 201  201FB        wait_1ms: CALL 1FB[delay_40us]               ; delay 40us
 202  19201                  SUB s2, 01                         ; count down to 0
 203  36201                  JUMP NZ, 201[wait_1ms]             ; and then return
 204  25000                  RETURN 
 205                         ; ===================================================================
 205                         ; === delay_50 ms() - delays execution for 50 miliseconds (20Hz)===
 205                         ; === Registers affected: s0, s1, s2, s3                          ===
 205                         ; ===================================================================
 205  01332      delay_50ms: LOAD s3, 32                        ; 50 x 1ms = 50ms
 206  20200       wait_50ms: CALL 200[delay_1ms]                ; delay 1ms
 207  19301                  SUB s3, 01                         ; count down to 0
 208  36206                  JUMP NZ, 206[wait_50ms]            ; and then return
 209  25000                  RETURN 
 20A                         ;*********************************************************************
 20A                         ; ===================================================================
 20A                         ; === delay_100 ms() - delays execution for 100 miliseconds (10Hz)===
 20A                         ; === Registers affected: s0, s1, s2, s3                          ===
 20A                         ; ===================================================================
 20A  01364     delay_100ms: LOAD s3, 64                        ; 100 x 1ms = 100ms
 20B  20200      wait_100ms: CALL 200[delay_1ms]                ; delay 1ms
 20C  19301                  SUB s3, 01                         ; count down to 0
 20D  3620B                  JUMP NZ, 20B[wait_100ms]           ; and then return
 20E  25000                  RETURN 
 20F                         ;*********************************************************************
 20F                         ; ==================================================================
 20F                         ; === delay_200 ms() - delays execution for 200 miliseconds (5Hz)===
 20F                         ; === Registers affected: s0, s1, s2, s3                         ===
 20F                         ; ==================================================================
 20F  013C8     delay_200ms: LOAD s3, C8                        ; 200 x 1ms = 200ms
 210  20200      wait_200ms: CALL 200[delay_1ms]                ; delay 1ms
 211  19301                  SUB s3, 01                         ; count down to 0
 212  36210                  JUMP NZ, 210[wait_200ms]           ; and then return
 213  25000                  RETURN 
 214                         ;*********************************************************************
 214                         ; ===============================================================
 214                         ; === delay_1000 ms() - delays execution for 1000 miliseconds ===
 214                         ; === Registers affected: s0, s1, s2, s3, s4                  ===
 214                         ; ===============================================================
 214  01405    delay_1000ms: LOAD s4, 05                        ; 5 x 200ms = 1000ms
 215  2020F     wait_1000ms: CALL 20F[delay_200ms]              ; delay 200ms
 216  19401                  SUB s4, 01                         ; count down to 0
 217  36215                  JUMP NZ, 215[wait_1000ms]          ; and then return
 218  25000                  RETURN 
 219                         ;*******************************************************************
 219                         ; ****** USE THIS FUNCTION FOR SIMULATION (waits 10 cycles) ******
 219                         ; ===========================================================
 219                         ; === delay_sim() - delays execution for 10 cycles        ===
 219                         ; === Registers affected: s0, s1, s2, s3                  ===
 219                         ; ===========================================================
 219  0130A       delay_sim: LOAD s3, 0A                        ; delay 10
 21A  00330        wait_sim: LOAD s3, s3                        ; NOP
 21B  19301                  SUB s3, 01                         ; count down to 0
 21C  3621A                  JUMP NZ, 21A[wait_sim]             ; and then return
 21D  25000                  RETURN 
 300                         ADDRESS 300
 300                         ;**********************************************************************************************************
 300                         ;**********************************************************************************************************
 300                         ;**********************************************************************************************************
 300                         ;***************          Simple test for the World I/F and Bot logic        ******************************
 300                         ;**********************************************************************************************************
 300  01D00     test_wrldIF: LOAD sD[LocX], 00                  ; initialize LocX and LocY to 0
 301  01C00                  LOAD sC[LocY], 00                  ;
 302  019FF                  LOAD s9[LMDist], FF                ; initialize LMDist and RMDist to FF
 303  018FF                  LOAD s8[RMDist], FF                ;
 304  09000      twrldIF_lp: INPUT s0, 00[PRD_MOTCTL_IN]        ; get motor controls from "system" and save in s0
 305  2D004                  OUTPUT s0, 04[PWR_SENSORS]         ; and write it to world I/F sensor register
 306  11D01                  ADD sD[LocX], 01                   ; increment LocX
 307  00CD0                  LOAD sC[LocY], sD[LocX]            ; LocY =2 * LocX
 308  14C06                  SL0 sC[LocY]                       ;
 309  2DD01                  OUTPUT sD[LocX], 01[PWR_LOCX]      ; and output them to world I/F
 30A  2DC02                  OUTPUT sC[LocY], 02[PWR_LOCY]      ;
 30B  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; write them to system I/F by pulsing load_sys_regs
 30C  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ;
 30D  19902                  SUB s9[LMDist], 02                 ; decrement LMDist and RMDist registers by 2 and 4
 30E  19804                  SUB s8[RMDist], 04                 ;
 30F  2D905                  OUTPUT s9[LMDist], 05[PWR_LMDIST]  ; and write them to world I/F
 310  2D806                  OUTPUT s8[RMDist], 06[PWR_RMDIST]  ;
 311  2D00D                  OUTPUT s0, 0D[PRW_LDMOTDIST]       ; write them to system I/F by pulsing load_dist_regs
 312  2D00D                  OUTPUT s0, 0D[PRW_LDMOTDIST]       ;
 313  2020F                  CALL 20F[delay_200ms]              ; and sleep for 200 ms
 314  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; toggle the "system registers updated" flag
 315  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; First write togles to 1, second write to 0
 316  22304                  JUMP 304[twrldIF_lp]               ; do this forever


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\rromano\Documents\GitHub\Nexys-A7-Sidescroller-Game\PGM Test\KCPSM6_Release9_30Sept14\\PSMS\Sidescroller version 2\bot31_pgm.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   16'd         
 timestamp_minutes 20'd         
 timestamp_seconds 35'd         
 datestamp_year    20'd         
 datestamp_month   12'd         
 datestamp_day     08'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PRD_MOTCTL_IN     00           bot31_pgm.psm
 PWR_LOCX          01           bot31_pgm.psm
 PWR_LOCY          02           bot31_pgm.psm
 PWR_BOTINFO       03           bot31_pgm.psm
 PWR_SENSORS       04           bot31_pgm.psm
 PWR_LMDIST        05           bot31_pgm.psm
 PWR_RMDIST        06           bot31_pgm.psm
 PRW_RSVD07        07           bot31_pgm.psm
 PWR_COLADR        08           bot31_pgm.psm
 PWR_ROWADR        09           bot31_pgm.psm
 PRD_LOCINFO       0A           bot31_pgm.psm
 PRW_RSVD0B        0B           bot31_pgm.psm
 PRW_LOADREGS      0C           bot31_pgm.psm
 PRW_LDMOTDIST     0D           bot31_pgm.psm
 PRW_UPDSYSREGS    0E           bot31_pgm.psm
 PRW_RSVD0F        0F           bot31_pgm.psm
 PRD_CONFIG        07           bot31_pgm.psm
 SP_ORTBASE        00           bot31_pgm.psm
 SP_ORTNO          17           bot31_pgm.psm
 SP_ORTNE          20           bot31_pgm.psm
 SP_ORTEA          31           bot31_pgm.psm
 SP_ORTSE          42           bot31_pgm.psm
 SP_ORTSO          53           bot31_pgm.psm
 SP_ORTSW          64           bot31_pgm.psm
 SP_ORTWE          75           bot31_pgm.psm
 SP_ORTNW          06           bot31_pgm.psm
 SP_XYTBASE        10           bot31_pgm.psm
 SP_XYTNO          0F           bot31_pgm.psm
 SP_XYTNE          1F           bot31_pgm.psm
 SP_XYTEA          10           bot31_pgm.psm
 SP_XYTSE          11           bot31_pgm.psm
 SP_XYTSO          01           bot31_pgm.psm
 SP_XYTSW          F1           bot31_pgm.psm
 SP_XYTWE          F0           bot31_pgm.psm
 SP_XYTNW          FF           bot31_pgm.psm
 SP_MVTBASE        20           bot31_pgm.psm
 SP_MVT10          00           bot31_pgm.psm
 SP_MVT32          00           bot31_pgm.psm
 SP_MVT54          CE           bot31_pgm.psm
 SP_MVT76          CE           bot31_pgm.psm
 SP_MVT98          CC           bot31_pgm.psm
 SP_MVTBA          EE           bot31_pgm.psm
 SP_MVTDC          D8           bot31_pgm.psm
 SP_MVTFE          4F           bot31_pgm.psm
 TEMP1             3F           bot31_pgm.psm
 TEMP2             3E           bot31_pgm.psm
 VS_LMTHRSH        30           bot31_pgm.psm
 VS_RMTHRSH        31           bot31_pgm.psm
 VS_MOTCMSK        32           bot31_pgm.psm
 VS_ENVSCTL        33           bot31_pgm.psm
 WSIZE_COLS        80           bot31_pgm.psm
 WSIZE_ROWS        80           bot31_pgm.psm
 WTHR_LMOT         02           bot31_pgm.psm
 WTHR_RMOT         02           bot31_pgm.psm
 WSTRT_COL         01           bot31_pgm.psm
 WSTRT_ROW         40           bot31_pgm.psm
 WTYPE_GND         00           bot31_pgm.psm
 WTYPE_BLKL        01           bot31_pgm.psm
 WTYPE_OBSTR       02           bot31_pgm.psm
 WTYPE_RSVD        03           bot31_pgm.psm
 DISTCTR_IVAL      00           bot31_pgm.psm
 OR_N              00           bot31_pgm.psm
 OR_NE             01           bot31_pgm.psm
 OR_E              02           bot31_pgm.psm
 OR_SE             03           bot31_pgm.psm
 OR_S              04           bot31_pgm.psm
 OR_SW             05           bot31_pgm.psm
 OR_W              06           bot31_pgm.psm
 OR_NW             07           bot31_pgm.psm
 MV_STOP           00           bot31_pgm.psm
 MV_FWD            04           bot31_pgm.psm
 MV_REV            08           bot31_pgm.psm
 MV_SLT            0C           bot31_pgm.psm
 MV_FLT            0D           bot31_pgm.psm
 MV_SRT            0E           bot31_pgm.psm
 MV_FRT            0F           bot31_pgm.psm
 MSK_RMBITS        0F           bot31_pgm.psm
 MSK_LMBITS        F0           bot31_pgm.psm
 MSK_MOTR_STS      0F           bot31_pgm.psm
 MSK_MOTSPD        01           bot31_pgm.psm
 MSK_VMOTSPD       07           bot31_pgm.psm
 DELAYVAL_1uS      24'd         bot31_pgm.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "08 Dec 2020"  
 timestamp$        "16:20:35"     



List of line labels

   Label            Addr  Source PSM File

 * start            000   bot31_pgm.psm
   main             004   bot31_pgm.psm
   emul_lp          00E   bot31_pgm.psm
   emul_lp01        01D   bot31_pgm.psm
   naptime          028   bot31_pgm.psm
   upd_sysregs      02A   bot31_pgm.psm
   upd_distregs     039   bot31_pgm.psm
   lkup_nib         03E   bot31_pgm.psm
   lkup_nib01       049   bot31_pgm.psm
   lkup_byte        04B   bot31_pgm.psm
   init_mvlkuptbl   04E   bot31_pgm.psm
   calc_movement    067   bot31_pgm.psm
   init_orlkuptbl   06C   bot31_pgm.psm
   next_orient      085   bot31_pgm.psm
   calc_orient      08A   bot31_pgm.psm
 * co_caseSTOP      08C   bot31_pgm.psm
   co_caseFWD       091   bot31_pgm.psm
   co_caseREV       095   bot31_pgm.psm
   co_caseSLT       09A   bot31_pgm.psm
   co_caseFLT       0A1   bot31_pgm.psm
   co_caseSRT       0AB   bot31_pgm.psm
   co_caseFRT       0B2   bot31_pgm.psm
   co_caseDFLT      0BC   bot31_pgm.psm
   co_endcase       0BD   bot31_pgm.psm
   init_xylkuptbl   0BE   bot31_pgm.psm
   next_xy          0D7   bot31_pgm.psm
   get_newxy        0E0   bot31_pgm.psm
   gnxy_01          0ED   bot31_pgm.psm
   gnxy_02          0EE   bot31_pgm.psm
   gnxy_03          0F2   bot31_pgm.psm
   gnxy_SLT         0F4   bot31_pgm.psm
   gnxy_11          0FC   bot31_pgm.psm
   gnxy_08          100   bot31_pgm.psm
   gnxy_09          101   bot31_pgm.psm
   gnxy_10          105   bot31_pgm.psm
   gnxy_00          107   bot31_pgm.psm
   gnxy_04          10D   bot31_pgm.psm
   gnxy_05          10E   bot31_pgm.psm
   gnxy_06          112   bot31_pgm.psm
   gnxy_nofwdrev    114   bot31_pgm.psm
   gnxy_chk0B       117   bot31_pgm.psm
   gnxy_07          11F   bot31_pgm.psm
   get_mapvalue     122   bot31_pgm.psm
   get_sensors      127   bot31_pgm.psm
 * gs_caseORN       12B   bot31_pgm.psm
   gs_caseORNE      139   bot31_pgm.psm
   gs_caseORE       147   bot31_pgm.psm
   gs_caseORSE      155   bot31_pgm.psm
   gs_caseORS       163   bot31_pgm.psm
   gs_caseORSW      171   bot31_pgm.psm
   gs_caseORW       17F   bot31_pgm.psm
   gs_caseORNW      18D   bot31_pgm.psm
   gs_errcase       19B   bot31_pgm.psm
   set_senvalues    19D   bot31_pgm.psm
   setsen_L0        1A8   bot31_pgm.psm
   setsen_L1        1AB   bot31_pgm.psm
   setsen_L2        1AE   bot31_pgm.psm
   setsen_L3        1B1   bot31_pgm.psm
   get_botinfo      1B2   bot31_pgm.psm
   adjthresh        1BB   bot31_pgm.psm
 * adjthr_onoff     1BC   bot31_pgm.psm
 * adjthr_vs        1C5   bot31_pgm.psm
   init_rojobot     1CE   bot31_pgm.psm
   rojobot          1D4   bot31_pgm.psm
   rojobot_02       1E9   bot31_pgm.psm
   rojobot_01       1EB   bot31_pgm.psm
   rojobot_04       1F0   bot31_pgm.psm
   rojobot_03       1F2   bot31_pgm.psm
   delay_1us        1F7   bot31_pgm.psm
   wait_1us         1F8   bot31_pgm.psm
   delay_40us       1FB   bot31_pgm.psm
   wait_40us        1FC   bot31_pgm.psm
   delay_1ms        200   bot31_pgm.psm
   wait_1ms         201   bot31_pgm.psm
   delay_50ms       205   bot31_pgm.psm
   wait_50ms        206   bot31_pgm.psm
 * delay_100ms      20A   bot31_pgm.psm
   wait_100ms       20B   bot31_pgm.psm
   delay_200ms      20F   bot31_pgm.psm
   wait_200ms       210   bot31_pgm.psm
 * delay_1000ms     214   bot31_pgm.psm
   wait_1000ms      215   bot31_pgm.psm
 * delay_sim        219   bot31_pgm.psm
   wait_sim         21A   bot31_pgm.psm
 * test_wrldIF      300   bot31_pgm.psm
   twrldIF_lp       304   bot31_pgm.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            148
 STAR              -

 AND               9
 OR                7
 XOR               -

 ADD              49
 ADDCY             -
 SUB              32
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0              12
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0              23
 SR1               -
 SRX               -
 SRA               2
 RR                -

 REGBANK           -

 INPUT             6
 OUTPUT           25
 OUTPUTK           -

 STORE             4
 FETCH             4

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             70
 JUMP@             -
 CALL             68
 CALL@             -
 RETURN           39
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
